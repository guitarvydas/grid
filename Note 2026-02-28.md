A brief sketch of where this is headed:

If you can run bash scripts, clone the repo (https://github.com/guitarvydas/grid) and run `./@make`.

I've skimped a lot, I don't understand the desired semantics yet, but, this grid code
```
' ---- Test 0: Hello World
Return "Hello, World!"
```
is transmogrified into this Python code:
```
import rtlib
subject = rtlib.fresh ()
#  ---- Test 0: Hello World #1
print ("Hello, World!") #2
```

... and ... this grid code:
```
' ---- Test 142: Function square with output | expected: {'A1': 25.0}
Define SQUARE as Function
 Input n as number
 Output sq as number
 push Sq = n ^ 2
End SQUARE
[A1] := square(5)
```

becomes:

```
import rtlib
subject = rtlib.fresh ()
#  ---- Test 142: Function square with output | expected: {'A1': 25.0} #1
def square (self): #2
    rtlib.input (subject, "n",  "number") #3
    rtlib.output (subject, "sq",  "number") #4
    rtlib.push (subject, "sq", n^2) #5
    #end square
#6
rtlib.cellAssign (subject, "a", 1, square(5))
#7
```

(and the third test (test02.grid) produces an error message)

If you want to poke around, look at the scripts `@makec`, `identity`, `semantics`, `emit-python`, and the `*.ohm` files and the `*.rwr` files, and the various intermediate results poured into `./intermediate/*`.

The semantics - as I understand thus far - of `grid` are so far removed from `python` that I imagine building a small "engin" for `grid` with an api hinted at by rtlib.py (very incomplete, but, maybe it is sufficient to give you ideas). You've probably already built most of the engine code, it just needs to be rearranged.

This appears to be a very unconventional approach, so ask questions no matter how basic they may seem. I think that the traditional approach is overly-complicated. Chopping the work up into stages makes it easier (albeit with a syntax that is foreign-looking at the moment).
