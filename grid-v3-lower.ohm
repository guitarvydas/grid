


GridLang {

  //----------------------------------------------------------------
  // Top-level
  //----------------------------------------------------------------

  Program = Statement+

  Statement
    = TypeDef
    | NumericSubtypeDef
    | FuncDef
    | SubprocessDef
    | PrivateHelperDef
    | InputDecl
    | OutputDecl
    | ForStmt
    | LetStmt
    | IfStmt
    | PushStmt
    | ReturnStmt
    | SubprocessCall
    | CellAssign
    | GlobalVarDecl
    | DimLabel


  //----------------------------------------------------------------
  // Type definitions
  //----------------------------------------------------------------

  TypeDef
    = caseInsensitive<"define"> identifier caseInsensitive<"as"> caseInsensitive<"type"> TypeParent? eol
      TypeMember*
      caseInsensitive<"end"> identifier eol

  TypeParent = "(" identifier ")"

  TypeMember
    = FuncDef
    | SubprocessDef
    | PrivateHelperDef
    | InputDecl
    | OutputDecl
    | CellAssign
    | ForStmt
    | LetStmt
    | PushStmt
    | SuperCall
    | GlobalVarDecl


  SuperCall = caseInsensitive<"super"> "(" ArgList ")" eol

  ArgList = ListOf<Expr, listSep>

  //----------------------------------------------------------------
  // Numeric subtype  e.g. Define RateValue as Type(Number) >= 0.0 <= 1.0
  //----------------------------------------------------------------

  NumericSubtypeDef
    = caseInsensitive<"define"> identifier caseInsensitive<"as">
      caseInsensitive<"type"> "(" identifier ")" NumericConstraint* eol
      caseInsensitive<"end"> identifier eol

  NumericConstraint = compOp Expr

  //----------------------------------------------------------------
  // Function / Subprocess / PrivateHelper definitions
  //----------------------------------------------------------------

  FuncDef
    = caseInsensitive<"define"> QualifiedName caseInsensitive<"as"> caseInsensitive<"sunction"> eol
      FuncMember*
      caseInsensitive<"end"> QualifiedName eol

  SubprocessDef
    = caseInsensitive<"define"> QualifiedName caseInsensitive<"as"> caseInsensitive<"subprocess"> eol
      FuncMember*
      caseInsensitive<"end"> QualifiedName eol

  PrivateHelperDef
    = caseInsensitive<"define"> "$"? QualifiedName caseInsensitive<"as"> caseInsensitive<"privateHelper"> eol
      FuncMember*
      caseInsensitive<"end"> "$"? QualifiedName eol

  FuncMember
    = InputDecl
    | OutputDecl
    | ForStmt
    | LetStmt
    | IfStmt
    | PushStmt
    | ReturnStmt
    | SubprocessCall
    | CellAssign
    | GlobalVarDecl


  QualifiedName = identifier ("." identifier)*

  //----------------------------------------------------------------
  // Input / Output declarations
  //----------------------------------------------------------------

  InputDecl  = caseInsensitive<"input"> InputVarList eol
  OutputDecl = caseInsensitive<"Output"> identifier caseInsensitive<"as"> TypeExpr InitOrEqClause? eol

  InputVarList = NonemptyListOf<InputVar, listSep>

  InputVar
    = identifier caseInsensitive<"as"> TypeExpr DefaultClause?  -- typed
    | identifier DefaultClause?                                   -- plain

  DefaultClause = caseInsensitive<"or"> "=" Expr

  InitOrEqClause
    = caseInsensitive<"init"> Expr  -- init
    | "=" Expr                       -- eq

  //----------------------------------------------------------------
  // FOR statement  (ordered most-specific first)
  //----------------------------------------------------------------

  ForStmt
    = ForLoopBlock
    | ForLoopInline
    | ForTypedWith
    | ForTypeInit
    | ForConstraint
    | ForDecl

  // For i in 1 to 3 do ... End
  // Also: For letter as text init expr do ... End
  ForLoopBlock
    = ForLoopInitBlock
    | ForLoopIterBlock

  ForLoopInitBlock
    = caseInsensitive<"sor"> identifier caseInsensitive<"as"> TypeExpr ForTypeInitOp Expr caseInsensitive<"do"> eol
      Statement*
      caseInsensitive<"end"> eol

  ForLoopIterBlock
    = caseInsensitive<"sor"> ForLoopBindings caseInsensitive<"do"> eol
      Statement*
      caseInsensitive<"end"> eol

  // For i in 1 to 3   (standalone / guard-style)
  ForLoopInline
    = caseInsensitive<"sor"> ForLoopBindings eol

  ForLoopBindings = NonemptyListOf<ForLoopBinding, andSep>

  ForLoopBinding
    = identifier caseInsensitive<"in"> RangeOrSet caseInsensitive<"step"> Expr caseInsensitive<"index"> identifier  -- withStepIndex
    | identifier caseInsensitive<"in"> RangeOrSet caseInsensitive<"index"> identifier                               -- withIndex
    | identifier caseInsensitive<"in"> RangeOrSet caseInsensitive<"step"> Expr                                      -- withStep
    | identifier caseInsensitive<"in"> RangeOrSet                                                                   -- plain

  RangeOrSet
    = ArrayLit   -- set
    | RangeExpr  -- range

  // For V as tensor with (name = "V", grid DIM {4,4,2} = expr)
  ForTypedWith
    = caseInsensitive<"sor"> identifier caseInsensitive<"as"> identifier
      caseInsensitive<"with"> "(" ForFieldList ")" eol

  ForFieldList = NonemptyListOf<ForField, listSep>

  ForField
    = identifier caseInsensitive<"dim"> DimSpec "=" Expr  -- dimField
    | identifier "=" Expr                                  -- eqField
    | identifier                                           -- bare

  // For acc as text init ""
  ForTypeInit
    = caseInsensitive<"sor"> identifier caseInsensitive<"as"> TypeExpr
      DimClause? ForTypeInitOp Expr eol

  ForTypeInitOp = caseInsensitive<"init"> | "="

  // For v <= vmax  (constraint only)
  ForConstraint
    = caseInsensitive<"sor"> identifier compOp Expr eol

  // For x as number = 42  /  For x as number  /  For x = expr  /  For a = e1 AND b = e2
  ForDecl
    = caseInsensitive<"sor"> ForDeclBody eol

  ForDeclBody
    = identifier caseInsensitive<"as"> TypeExpr DimClause? caseInsensitive<"of"> identifier "=" Expr  -- typedUnitInit
    | identifier caseInsensitive<"as"> TypeExpr DimClause? ForTypeInitOp Expr                         -- typedInit
    | identifier caseInsensitive<"as"> TypeExpr DimClause?                                             -- typedOnly
    | identifier caseInsensitive<"of"> identifier "=" Expr                                            -- unitInit
    | identifier caseInsensitive<"of"> identifier                                                      -- unitOnly
    | NonemptyListOf<ForSingleEq, andSep>                                                              -- multiEq

  ForSingleEq = identifier "=" Expr

  //----------------------------------------------------------------
  // DIM clause
  //----------------------------------------------------------------

  DimClause = caseInsensitive<"dim"> DimSpec

  DimSpec
    = "{" NonemptyListOf<DimDim, listSep> "}"  -- structured
    | "{" "}"                                   -- empty
    | "*"                                       -- star
    | Expr                                      -- scalar

  DimDim
    = identifier ":" DimSize  -- named
    | DimSize                 -- anon

  DimSize
    = "*"       -- star
    | RangeExpr -- range
    | Expr      -- expr

  //----------------------------------------------------------------
  // LET statement
  //----------------------------------------------------------------

  LetStmt
    = LetBlock
    | LetInline

  LetBlock
    = caseInsensitive<"let"> LetBindings caseInsensitive<"then"> eol
      Statement*
      caseInsensitive<"end"> eol

  LetInline
    = caseInsensitive<"let"> LetBindings eol

  LetBindings = NonemptyListOf<LetBinding, andSep>

  LetBinding
    = identifier caseInsensitive<"as"> TypeExpr DimClause?  -- typedDecl
    | ArrayIndexExpr "=" Expr                                -- arrayIndex
    | identifier compOp Expr                                 -- constrained
    | identifier "=" Expr                                    -- eq

  //----------------------------------------------------------------
  // IF statement
  //----------------------------------------------------------------

  IfStmt
    = IfBlock
    | IfInline
    | IfGuard

  IfBlock
    = caseInsensitive<"if"> CondExpr caseInsensitive<"then"> eol
      Statement*
      ElseIfClause*
      ElseClause?
      caseInsensitive<"end"> eol

  ElseIfClause
    = caseInsensitive<"elseIf"> CondExpr caseInsensitive<"then"> eol
      Statement*

  ElseClause
    = caseInsensitive<"else"> eol
      Statement*

  // single-line: If cond then stmt [else stmt]
  IfInline
    = caseInsensitive<"if"> CondExpr caseInsensitive<"then"> Statement
      (caseInsensitive<"else"> Statement)?

  // guard: If cond   (controls the block above it)
  IfGuard = caseInsensitive<"if"> CondExpr eol

  //----------------------------------------------------------------
  // PUSH statement
  //----------------------------------------------------------------

  PushStmt = caseInsensitive<"push"> LValue "=" Expr eol

  LValue
    = CellRef                      -- cell
    | identifier ArrayIndexSuffix+ -- indexed
    | QualifiedName                -- var

  ArrayIndexSuffix
    = "{" NonemptyListOf<Expr, listSep> "}"  -- curly
    | "(" NonemptyListOf<Expr, listSep> ")"  -- paren
    | "[" NonemptyListOf<Expr, listSep> "]"  -- square

  //----------------------------------------------------------------
  // RETURN statement
  //----------------------------------------------------------------

  ReturnStmt = caseInsensitive<"Return"> Expr eol

  //----------------------------------------------------------------
  // Subprocess call (standalone)
  //   SplitName([A1], [^B1])
  //----------------------------------------------------------------

  SubprocessCall = QualifiedName "(" SubprocessArgList ")" eol

  SubprocessArgList = ListOf<SubprocessArg, listSep>

  SubprocessArg
    = CellRef  -- cell
    | Expr     -- expr

  //----------------------------------------------------------------
  // Cell assignment
  //----------------------------------------------------------------

  CellAssign
    = CellRef ":" identifier caseInsensitive<"as"> TypeExpr eol  -- typedDecl
    | CellRef ":" identifier "=" Expr eol                        -- varAssign
    | CellRef ":=" Expr eol                                      -- directAssign

  //----------------------------------------------------------------
  // Global variable declaration
  //----------------------------------------------------------------

  GlobalVarDecl
    = ":" "$"? identifier caseInsensitive<"as"> TypeExpr
      DimClause? InConstraint? VarInitClause? eol  -- typed
    | ":" identifier "=" RangeOrExpr eol            -- simple
    | ":" identifier eol                             -- bareDecl

  RangeOrExpr = RangeExpr | Expr

  InitOrEqClauseRange
    = caseInsensitive<"init"> RangeOrExpr  -- init
    | "=" RangeOrExpr                      -- eq

  // Accepts "= expr", "init expr", or "or = expr"
  VarInitClause
    = caseInsensitive<"or"> "=" RangeOrExpr  -- orEq
    | caseInsensitive<"init"> RangeOrExpr    -- init
    | "=" RangeOrExpr                        -- eq

  InConstraint
    = caseInsensitive<"in"> "{" NonemptyListOf<Expr, listSep> "}"  -- set
    | caseInsensitive<"in"> RangeExpr                               -- range

  //----------------------------------------------------------------
  // Named dimension label assignment
  //   Results!Quarter.Label{"Q1", "Q2", "Q3", "Q4"}
  //----------------------------------------------------------------

  DimLabel
    = identifier "!" identifier "." caseInsensitive<"label">
      "{" NonemptyListOf<Expr, listSep> "}" eol

  //----------------------------------------------------------------
  // Condition expressions
  //----------------------------------------------------------------

  CondExpr
    = CondExpr caseInsensitive<"and"> CondTerm  -- and
    | CondExpr caseInsensitive<"or">  CondTerm  -- or
    | CondTerm

  CondTerm
    = Expr caseInsensitive<"not"> "=" Expr              -- notEq
    | Expr caseInsensitive<"in"> InRHS                  -- in
    | Expr caseInsensitive<"as"> TypeExpr DimClause?    -- typeCheck
    | Expr caseInsensitive<"of"> identifier             -- unitCheck
    | Expr caseInsensitive<"dim"> DimSpec               -- dimCheck
    | Expr compOp Expr                                  -- compare
    | Expr                                              -- expr

  InRHS
    = "{" NonemptyListOf<Expr, listSep> "}"  -- set
    | RangeExpr                               -- range

  //----------------------------------------------------------------
  // Expressions
  //----------------------------------------------------------------

  Expr = ConcatExpr

  ConcatExpr
    = ConcatExpr "&" AddExpr  -- concat
    | AddExpr

  AddExpr
    = AddExpr "+" MulExpr  -- add
    | AddExpr "-" MulExpr  -- sub
    | MulExpr

  MulExpr
    = MulExpr "*"  ExpExpr                          -- mul
    | MulExpr "/"  ExpExpr                          -- div
    | MulExpr "\\" ExpExpr                          -- intDiv
    | MulExpr caseInsensitive<"mod"> ExpExpr        -- mod
    | ExpExpr

  ExpExpr
    = UnaryExpr "^" ExpExpr  -- exp
    | UnaryExpr

  UnaryExpr
    = "-" UnaryExpr  -- neg
    | "+" UnaryExpr  -- pos
    | PipeExpr

  PipeExpr
    = PipeExpr "|" PostfixExpr  -- pipe
    | PostfixExpr

  PostfixExpr
    = PostfixExpr "." identifier                              -- member
    | PostfixExpr "!" identifier "(" Expr ")"                -- dimAccess
    | PostfixExpr "{" NonemptyListOf<Expr, listSep> "}"      -- curlyIndex
    | PostfixExpr "(" ListOf<Expr, listSep> ")"              -- call
    | PostfixExpr "[" NonemptyListOf<Expr, listSep> "]"      -- squareIndex
    | PostfixExpr caseInsensitive<"dim"> DimSpec             -- dim
    | PrimaryExpr

  PrimaryExpr
    = SpecialValue        -- special
    | InterpolatedString  -- interp
    | PlainString         -- string
    | number              -- number
    | ArrayLit            -- array
    | NewExpr             -- new
    | CellRef             -- cell
    | FuncCallExpr        -- func
    | identifier          -- ident
    | "(" Expr ")"        -- paren

  // new Point(1.0, 2.0)  /  new Point with (x, y)  /  new Point(args) with (fields)
  NewExpr
    = caseInsensitive<"new"> identifier "(" ListOf<Expr, listSep> ")" caseInsensitive<"with"> "(" NewWithList ")"  -- withArgsAndFields
    | caseInsensitive<"new"> identifier caseInsensitive<"with"> "(" NewWithList ")"                                -- withFields
    | caseInsensitive<"new"> identifier "(" ListOf<Expr, listSep> ")"                                              -- withArgs
    | caseInsensitive<"new"> identifier                                                                             -- bare

  NewWithList = NonemptyListOf<NewWithField, listSep>

  NewWithField
    = identifier "=" Expr  -- namedField
    | identifier           -- shorthand

  // Function calls as expressions:  SQRT(100)  /  sum{a, b}  /  sum[A1:A2]
  FuncCallExpr
    = identifier "{" NonemptyListOf<Expr, listSep> "}"  -- curlyArgs
    | identifier "[" CellRef "]"                         -- rangeArg
    | identifier "(" ListOf<Expr, listSep> ")"           -- parenArgs

  //----------------------------------------------------------------
  // Range expression   1 to 6 step 1.5
  //----------------------------------------------------------------

  RangeExpr
    = Expr caseInsensitive<"to"> Expr caseInsensitive<"step"> Expr  -- withStep
    | Expr caseInsensitive<"to"> Expr                               -- plain

  //----------------------------------------------------------------
  // Array literal  {1, 2, 3}  /  {1, 2; 3, 4}
  //----------------------------------------------------------------

  ArrayLit = "{" NonemptyListOf<ArrayRow, rowSep> "}"

  ArrayRow = NonemptyListOf<Expr, listSep>

  //----------------------------------------------------------------
  // Cell references
  //
  //   [A1]   [^B2]   [A{i}]   [A1:C2]   [{i :A}5]
  //----------------------------------------------------------------

  CellRef
    = "[" "^"? CellRange "]"  -- range
    | "[" "^"? CellAddr "]"   -- single

  CellRange = CellAddr ":" CellAddr

  CellAddr
    = InterpColExpr InterpRowExpr  -- bothInterp
    | ColName InterpRowExpr        -- interpRow
    | InterpColExpr RowNum         -- interpCol
    | ColName RowNum               -- plain

  // {i :A}  — offset from base column A
  InterpColExpr = "{" Expr ":" ColName "}"

  // {n}  /  {n + 1}
  InterpRowExpr = "{" Expr "}"

  ColName = letter+

  RowNum = digit+

  //----------------------------------------------------------------
  // Array index expression used in LetBinding LHS
  //   D{i+1, 1}  /  D(k)  /  D[A1]
  //----------------------------------------------------------------

  ArrayIndexExpr
    = identifier "{" NonemptyListOf<Expr, listSep> "}"  -- curly
    | identifier "(" NonemptyListOf<Expr, listSep> ")"  -- paren
    | identifier "[" CellAddr "]"                        -- cell

  //----------------------------------------------------------------
  // Type expressions
  //----------------------------------------------------------------

  TypeExpr
    = caseInsensitive<"number">  -- number
    | caseInsensitive<"text">    -- text
    | identifier                 -- userDefined

  //----------------------------------------------------------------
  // Special values
  //----------------------------------------------------------------

  SpecialValue
    = "-" "#INF"  -- negInf
    | "#INF"      -- inf
    | "#N/A"      -- na

  //----------------------------------------------------------------
  // String literals
  //----------------------------------------------------------------

  // "hello"  /  "I say ""Hello"""
  PlainString = "\"" PlainStringChar* "\""

  PlainStringChar
    = "\"\""     -- escapedQuote
    | ~"\"" any  -- other

  // $"Hello, {name}!"
  InterpolatedString = "$\"" InterpSegment* "\""

  InterpSegment
    = "{{{" ~"*"            -- tripleEscape
    | "{{" ~"*"             -- doubleEscape
    | "{*" (~"}" any)* "}"  -- starEscape
    | "{}"                  -- emptyBraces
    | "{" InterpContent "}" -- interpolate
    | ~("\"" | "{") any     -- literal

  InterpContent = Expr (spaces "," spaces Expr)?  // {var} or {var, width}

  //----------------------------------------------------------------
  // Numbers
  //----------------------------------------------------------------

  number = digit+ ("." digit+)? (("e" | "E") ("+" | "-")? digit+)?

  //----------------------------------------------------------------
  // Comparison operators
  //----------------------------------------------------------------

  compOp
    = "<="  -- lte
    | ">="  -- gte
    | "<"   -- lt
    | ">"   -- gt
    | "="   -- eq

  //----------------------------------------------------------------
  // Separators (arity-1 rules, used inside both syntactic and lexical rules)
  //----------------------------------------------------------------

  listSep = spaces "," spaces

  rowSep = spaces ";" spaces

  andSep = spaces caseInsensitive<"and"> spaces

  //----------------------------------------------------------------
  // Identifiers  (keywords are still valid identifiers in context)
  //----------------------------------------------------------------

  identifier = (letter | "_") (alnum | "_")*

  //----------------------------------------------------------------
  // Inline comment
  //----------------------------------------------------------------

  comment = spaces "'" (~"\n" any)*

  //----------------------------------------------------------------
  // End-of-line  (newlines are significant — statements end here)
  // Horizontal whitespace only in "spaces"; newlines stay visible.
  //----------------------------------------------------------------

  eol
    = comment? "\r\n" spaces  -- crlf
    | comment? "\n" spaces    -- lf
    | spaces &eof             -- atEof

  eof = ~any

  //----------------------------------------------------------------
  // Override default "spaces" to horizontal whitespace only
  //----------------------------------------------------------------

  spaces := (" " | "\t")*

}
