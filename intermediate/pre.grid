⎝ ---- Test 1: Basic calculation | expected: {'A1': 51}⎠  ⎩1⎭
[❲a1❳] : ❲a❳ = 51  ⎩2⎭
  ⎩3⎭
⎝ ---- Test 2: Arithmetic with reference | expected: {'A1': 51, 'A2': 0.055, 'A3': 51.055}⎠  ⎩4⎭
[❲a1❳] := 51  ⎩5⎭
[❲a2❳] := ([❲a1❳] + 15) / 1.2❲e3❳  ⎩6⎭
[❲a3❳] := ❲sum❳[❲a1❳:❲a2❳]  ⎩7⎭
  ⎩8⎭
⎝ ---- Test 3: Variable in cell definition | expected: {'A1': 51, 'A2': 0.055, 'A3': 51.055}⎠  ⎩9⎭
[❲a1❳] : ❲a❳ = 51  ⎩10⎭
[❲a2❳] : ❲b❳ = (❲a❳ + 15) / 1.2❲e3❳  ⎩11⎭
[❲a3❳] : ❲c❳ = ❲sum❳([❲a1❳:❲a2❳])  ⎩12⎭
  ⎩13⎭
⎝ ---- Test 4: Global variables and sum{} | expected: {'A1': 51, 'A2': 0.055, 'A3': 51.055}⎠  ⎩14⎭
: ❲a❳ = 51  ⎩15⎭
: ❲b❳ = (❲a❳ + 15) / 1.2❲e3❳  ⎩16⎭
: ❲c❳ = ❲sum❳{❲a❳, ❲b❳}  ⎩17⎭
[❲a1❳] := ❲a❳  ⎩18⎭
[❲a2❳] := ❲b❳  ⎩19⎭
[❲a3❳] := ❲c❳  ⎩20⎭
  ⎩21⎭
⎝ ---- Test 5: Inline comment parsing | expected: {'AB2': 33}⎠  ⎩22⎭
[❲ab2❳] := 33 ⎝28th column⎠  ⎩23⎭
  ⎩24⎭
⎝ ---- Test 6: Horizontal array assignment from inline var | expected: {'A1': 51, 'B2': 12, 'C2': 0.055, 'D2': 52, 'E2': 8}⎠  ⎩25⎭
[❲a1❳] : ❲a❳ = 51  ⎩26⎭
[^❲b2❳] := {12, (15 + ❲a❳) / 1.2❲e3❳, 1+[❲a1❳], 8}  ⎩27⎭
  ⎩28⎭
⎝ ---- Test 7: Horizontal array from variable | expected: {'A1': 51, 'B2': 12, 'C2': 0.055, 'D2': 52, 'E2': 8}⎠  ⎩29⎭
[❲a1❳] : ❲a❳ = 51  ⎩30⎭
: ❲b❳ = {12, (15 + ❲a❳) / 1.2❲e3❳, 1+[❲a1❳], 8}  ⎩31⎭
[^❲b2❳] := ❲b❳  ⎩32⎭
  ⎩33⎭
⎝ ---- Test 8: Math function - SQRT | expected: {'A1': 6.0}⎠  ⎩34⎭
[❲a1❳] := 2*( ❲sqrt❳(100) - 7 )  ⎩35⎭
  ⎩36⎭
⎝ ---- Test 9: Interpolation with cell reference | expected: {'A2': 33, 'A3': -4.9}⎠  ⎩37⎭
: ❲n❳ = 2  ⎩38⎭
[❲a❳{ ❲n❳ }] := 33  ⎩39⎭
[❲a❳{❲n❳ + 1}] := -4.9  ⎩40⎭
  ⎩41⎭
⎝ ---- Test 10: 2D range assign and slice | expected: {'A1': 1, 'A2': 10, 'A3': 1, 'B1': 2, 'B2': 11, 'B3': 2, 'C1': 3, 'C2': 12, 'C3': 3}⎠  ⎩42⎭
[❲a1❳:❲c2❳] := {1, 2, 3; 10, 11, 12}  ⎩43⎭
[^❲a3❳] := [❲a1❳:❲c1❳]  ⎩44⎭
  ⎩45⎭
⎝ ---- Test 11: Range read and vertical assignment | expected: {'A1': 1, 'A2': 2, 'A3': 3, 'B1': 2, 'B2': 3}⎠  ⎩46⎭
[^❲a1❳] := {1; 2; 3}  ⎩47⎭
[❲b1❳:❲b2❳] := [❲a2❳:❲a3❳]  ⎩48⎭
  ⎩49⎭
⎝ ---- Test 12: Text type assignment | expected: {'A1': 'Hello'}⎠  ⎩50⎭
: ❲t❳ as text = "Hello"  ⎩51⎭
[❲a1❳] := ❲t❳  ⎩52⎭
  ⎩53⎭
⎝ ---- Test 13: Cell var definition | expected: {'A1': 3}⎠  ⎩54⎭
[❲a1❳] : ❲e❳ = 3  ⎩55⎭
  ⎩56⎭
⎝ ---- Test 14: Number type declaration | expected: {'A1': 42}⎠  ⎩57⎭
: ❲x❳ as number = 42  ⎩58⎭
[❲a1❳] := ❲x❳  ⎩59⎭
  ⎩60⎭
⎝ ---- Test 15: Number declaration with scientific notation | expected: {'A1': 0.0001234}⎠  ⎩61⎭
: ❲num❳ as number = 12.34❲e❳-5  ⎩62⎭
[❲a1❳] := ❲num❳  ⎩63⎭
  ⎩64⎭
⎝ ---- Test 16: Number sequence with custom step | expected: {'B1': 1.0, 'C1': 2.5, 'D1': 4.0, 'E1': 5.5}⎠  ⎩65⎭
: ❲seq❳ = 1 to 6 step 1.5  ⎩66⎭
[^❲b1❳] := ❲seq❳  ⎩67⎭
  ⎩68⎭
⎝ ---- Test 17: Interpolated text | expected: {'A1': 'Hello, world!'}⎠  ⎩69⎭
: ❲name❳ as text = "world"  ⎩70⎭
[❲a1❳] := $"Hello, {name}!"  ⎩71⎭
  ⎩72⎭
⎝ ---- Test 18: Self-referential assignment (should fail) | expected: error⎠  ⎩73⎭
: ❲x❳ = ❲x❳  ⎩74⎭
  ⎩75⎭
⎝ ---- Test 19: Variable before definition | expected: {'A1': 6}⎠  ⎩76⎭
: ❲y❳ = ❲x❳ + 1  ⎩77⎭
: ❲x❳ as number = 5  ⎩78⎭
[❲a1❳] := ❲y❳  ⎩79⎭
  ⎩80⎭
⎝ ---- Test 20: Integer division | expected: {'A1': 3}⎠  ⎩81⎭
[❲a1❳] := 10 \ 3  ⎩82⎭
  ⎩83⎭
⎝ ---- Test 21: Exponentiation | expected: {'A1': 8}⎠  ⎩84⎭
[❲a1❳] := 2 ^ 3  ⎩85⎭
  ⎩86⎭
⎝ ---- Test 22: Modulus | expected: {'A1': 1}⎠  ⎩87⎭
[❲a1❳] := 10 mod 3  ⎩88⎭
  ⎩89⎭
⎝ ---- Test 23: Special value #INF | expected: {'A1': inf}⎠  ⎩90⎭
[❲a1❳] := #❲inf❳  ⎩91⎭
  ⎩92⎭
⎝ ---- Test 24: Special value -#INF | expected: {'A1': -inf}⎠  ⎩93⎭
[❲a1❳] := -#❲inf❳  ⎩94⎭
  ⎩95⎭
⎝ ---- Test 25: Special value #N/A | expected: {'A1': nan}⎠  ⎩96⎭
[❲a1❳] := #❲n❳/❲a❳  ⎩97⎭
  ⎩98⎭
⎝ ---- Test 26: Text concatenation | expected: {'A1': 'Hello, world'}⎠  ⎩99⎭
: ❲t1❳ as text = "Hello"  ⎩100⎭
: ❲t2❳ as text = "world"  ⎩101⎭
[❲a1❳] := ❲t1❳ & ", " & ❲t2❳  ⎩102⎭
  ⎩103⎭
⎝ ---- Test 27: Quote escaping | expected: {'A1': 'I say "Hello"'}⎠  ⎩104⎭
: ❲q❳ as text = "I say "Hello""  ⎩105⎭
[❲a1❳] := ❲q❳  ⎩106⎭
  ⎩107⎭
⎝ ---- Test 28: Padding right | expected: {'A1': 'Number:    42'}⎠  ⎩108⎭
: ❲num❳ = 42  ⎩109⎭
[❲a1❳] := $"Number: {num, 5}"  ⎩110⎭
  ⎩111⎭
⎝ ---- Test 29: Padding left | expected: {'A1': 'Number: 42   '}⎠  ⎩112⎭
: ❲num❳ = 42  ⎩113⎭
[❲a1❳] := $"Number: {num, -5}"  ⎩114⎭
  ⎩115⎭
⎝ ---- Test 30: Multi-line interpolation | expected: {'A1': '{Loudly} I say:\n"Hello", world!'}⎠  ⎩116⎭
: ❲name❳ = "world"  ⎩117⎭
[❲a1❳] := $"{*Loudly} I say:  
		"Hello", {name}!"  ⎩118⎭
  ⎩119⎭
⎝ ---- Test 31: Empty braces | expected: {'A1': 'Empty: {}'}⎠  ⎩120⎭
[❲a1❳] := $"Empty: {}"  ⎩121⎭
  ⎩122⎭
⎝ ---- Test 32: Escaped brace | expected: {'A1': 'Escaped: {{{star'}⎠  ⎩123⎭
[❲a1❳] := $"Escaped: {{{*star"  ⎩124⎭
  ⎩125⎭
⎝ ---- Test 33: Escaped brace with closing brace | expected: {'A1': 'Escaped: {{{star}'}⎠  ⎩126⎭
[❲a1❳] := $"Escaped: {{{*star}"  ⎩127⎭
  ⎩128⎭
⎝ ---- Test 34: Number sequence default step | expected: {'A1': 1, 'B1': 2, 'C1': 3, 'D1': 4, 'E1': 5, 'F1': 6}⎠  ⎩129⎭
: ❲dice❳ = 1 to 6  ⎩130⎭
[^❲a1❳] := ❲dice❳  ⎩131⎭
  ⎩132⎭
⎝ ---- Test 35: Point type spilling on grid | expected: {'A3': -4.3, 'B3': 2.1}⎠  ⎩133⎭
Define ❲point❳ as Type  ⎩134⎭
: ❲x❳ as number  ⎩135⎭
: ❲y❳ as number  ⎩136⎭
End ❲point❳  ⎩137⎭
: ❲p❳ = new ❲point❳(-4.3, 2.1)  ⎩138⎭
[^❲a3❳] := ❲p❳  ⎩139⎭
  ⎩140⎭
⎝ ---- Test 36: Array of Points spilling on grid | expected: {'C3': 1, 'C4': 3, 'D3': 2, 'D4': 4}⎠  ⎩141⎭
Define ❲dot❳ as Type  ⎩142⎭
: ❲x❳ as number  ⎩143⎭
: ❲y❳ as number  ⎩144⎭
End ❲dot❳  ⎩145⎭
: ❲p1❳ = new ❲dot❳(1, 2)  ⎩146⎭
: ❲p2❳ = new ❲dot❳(3, 4)  ⎩147⎭
[^❲c3❳] := {❲p1❳, ❲p2❳}  ⎩148⎭
  ⎩149⎭
⎝ ---- Test 37: Nested Rectangle type spilling on grid | expected: {'A1': 0, 'B1': 10, 'C1': 5, 'D1': 3}⎠  ⎩150⎭
Define ❲point❳ as Type  ⎩151⎭
: ❲x❳ as number  ⎩152⎭
: ❲y❳ as number  ⎩153⎭
End ❲point❳  ⎩154⎭
Define ❲rectangle❳ as Type  ⎩155⎭
: ❲top❳ as ❲point❳  ⎩156⎭
: ❲bottom❳ as ❲point❳  ⎩157⎭
End ❲rectangle❳  ⎩158⎭
[^❲a1❳] := new ❲rectangle❳(new ❲point❳(0, 10), new ❲point❳(5, 3))  ⎩159⎭
  ⎩160⎭
⎝ ---- Test 38: Point type assigned to single cell | expected: {'A1': {'x': -4.3, 'y': 2.1}}⎠  ⎩161⎭
Define ❲point❳ as Type  ⎩162⎭
	: ❲x❳ as number  ⎩163⎭
	: ❲y❳ as number  ⎩164⎭
End ❲point❳  ⎩165⎭
: ❲p❳ = new ❲point❳(-4.3, 2.1)  ⎩166⎭
[❲a1❳] := ❲p❳  ⎩167⎭
  ⎩168⎭
⎝ ---- Test 39: Access field of point type | expected: {'A3': 2.1}⎠  ⎩169⎭
Define ❲point❳ as Type  ⎩170⎭
: ❲x❳ as number  ⎩171⎭
: ❲y❳ as number  ⎩172⎭
End ❲point❳  ⎩173⎭
: ❲p❳ = new ❲point❳(-4.3, 2.1)  ⎩174⎭
[❲a3❳] := ❲p❳.❲y❳  ⎩175⎭
  ⎩176⎭
⎝ ---- Test 40: Concatenation with interpolation | expected: {'A1': 'I say- hello world!'}⎠  ⎩177⎭
: ❲m❳ = "hello"  ⎩178⎭
[❲a1❳] := "I say-" & $" {m} world!"  ⎩179⎭
  ⎩180⎭
⎝ ---- Test 41: Nested {* interpolation | expected: {'A1': '{{'}⎠  ⎩181⎭
[❲a1❳] := $"{{*"  ⎩182⎭
  ⎩183⎭
⎝ ---- Test 42: Dimension constraint | expected: {'A1': 0}⎠  ⎩184⎭
: ❲weights❳ as number dim {0 to 10, 0 to 10} = 0  ⎩185⎭
[❲a1❳] := ❲weights❳{0, 0}  ⎩186⎭
  ⎩187⎭
⎝ ---- Test 43: Multi-dimensional addition | expected: {'A1': [[1.0, 5.0], [13.0, 15.0]]}⎠  ⎩188⎭
[❲a1❳] := {0, 3; 10, 11} + {1, 2; 3, 4}  ⎩189⎭
  ⎩190⎭
⎝ ---- Test 44: Multi-dimensional subtraction | expected: {'A1': [[-1.0, 1.0], [7.0, 7.0]]}⎠  ⎩191⎭
[❲a1❳] := {0, 3; 10, 11} - {1, 2; 3, 4}  ⎩192⎭
  ⎩193⎭
⎝ ---- Test 45: Multi-dimensional multiplication | expected: {'A1': [[0.0, 6.0], [30.0, 44.0]]}⎠  ⎩194⎭
[❲a1❳] := {0, 3; 10, 11} * {1, 2; 3, 4}  ⎩195⎭
  ⎩196⎭
⎝ ---- Test 46: Multi-dimensional division | expected: {'A1': [[0.0, 1.5], [3.3333333333333335, 2.75]]}⎠  ⎩197⎭
[❲a1❳] := {0, 3; 10, 11} / {1, 2; 3, 4}  ⎩198⎭
  ⎩199⎭
⎝ ---- Test 47: Multi-dimensional exponentiation | expected: {'A1': [[0.0, 9.0], [1000.0, 14641.0]]}⎠  ⎩200⎭
[❲a1❳] := {0, 3; 10, 11} ^ {1, 2; 3, 4}  ⎩201⎭
  ⎩202⎭
⎝ ---- Test 48: Multi-dimensional modulo | expected: {'A1': [[0.0, 1.0], [1.0, 3.0]]}⎠  ⎩203⎭
[❲a1❳] := {0, 3; 10, 11} mod {1, 2; 3, 4}  ⎩204⎭
  ⎩205⎭
⎝ ---- Test 49: Multi-dimensional integer division | expected: {'A1': [[0.0, 1.0], [3.0, 2.0]]}⎠  ⎩206⎭
[❲a1❳] := {0, 3; 10, 11} \ {1, 2; 3, 4}  ⎩207⎭
  ⎩208⎭
⎝ ---- Test 50: Pipe operator | expected: {'A1': 1.0, 'B1': 2.0, 'A2': 3.0, 'B2': 4.0, 'A3': -5.0, 'B3': -6.0}⎠  ⎩209⎭
[^❲a1❳] := {1, 2} | {3, 4} | {-5, -6}  ⎩210⎭
  ⎩211⎭
⎝ ---- Test 51: Dim reshape | expected: {'A1': [[10], [11]]}⎠  ⎩212⎭
[❲a1❳] := {10, 11} dim {*, 1}  ⎩213⎭
  ⎩214⎭
⎝ ---- Test 52: Range with 1D vertical | expected: {'B2': 9, 'B3': 8, 'B4': 7}⎠  ⎩215⎭
[❲b2❳:❲b4❳] := {9, 8, 7}  ⎩216⎭
  ⎩217⎭
⎝ ---- Test 53: Range with 1D repeated | expected: {'A2': 1, 'A3': 1, 'A4': 1, 'B2': 2, 'B3': 2, 'B4': 2}⎠  ⎩218⎭
[❲a2❳:❲b4❳] := {1, 2}  ⎩219⎭
  ⎩220⎭
⎝ ---- Test 54: Named dimensions | expected: {'A1': 4}⎠  ⎩221⎭
: ❲results❳ as number dim {❲dept❳: *, ❲quarter❳: 4} = {9, 4, 5, 1}  ⎩222⎭
❲results❳!❲quarter❳.Label{"Q1", "Q2", "Q3", "Q4"}  ⎩223⎭
[❲a1❳] := ❲results❳!❲quarter❳("Q2")  ⎩224⎭
  ⎩225⎭
⎝ ---- Test 55: Assign and access dimensioned array | expected: {'A1': 10, 'B1': 20, 'B2': 20, 'C1': 30, 'D1': 40}⎠  ⎩226⎭
[❲a1❳:❲d1❳] := {10, 20, 30, 40}  ⎩227⎭
: ❲results❳ as number dim {❲dept❳: *, ❲quarter❳: 4} = [❲a1❳:❲d1❳]  ⎩228⎭
❲results❳!❲quarter❳.Label{"Q1", "Q2", "Q3", "Q4"}  ⎩229⎭
[❲b2❳] := ❲results❳!❲quarter❳("Q2")  ⎩230⎭
  ⎩231⎭
⎝ ---- Test 56: Multi-dimensional addressing | expected: {'A1': 20, 'A2': 10, 'B2': 20, 'C2': 30, 'D2': 40}⎠  ⎩232⎭
[❲a2❳:❲d2❳] := {10, 20, 30, 40}  ⎩233⎭
: ❲results❳ as number dim {❲dept❳: *, ❲quarter❳: 4} = [❲a2❳:❲d2❳]  ⎩234⎭
[❲a1❳] := ❲results❳[❲b1❳]  ⎩235⎭
  ⎩236⎭
⎝ ---- Test 57: FOR with already defined variable | expected: error⎠  ⎩237⎭
: ❲x❳ = 34  ⎩238⎭
For ❲x❳ as number  ⎩239⎭
  ⎩240⎭
⎝ ---- Test 58: FOR with LET defining local variable | expected: {'A1': 34}⎠  ⎩241⎭
For ❲x❳ = 34  ⎩242⎭
Let ❲x❳ as number  ⎩243⎭
[❲a1❳] := ❲x❳  ⎩244⎭
  ⎩245⎭
⎝ ---- Test 59: FOR block with LET defining local variable | expected: {'A1': 34}⎠  ⎩246⎭
For ❲x❳ = 34 do  ⎩247⎭
    Let ❲x❳ as number Then  ⎩248⎭
        [❲a1❳] := ❲x❳  ⎩249⎭
    End  ⎩250⎭
End  ⎩251⎭
  ⎩252⎭
⎝ ---- Test 60: LET block with FOR using already declared variable | expected: error⎠  ⎩253⎭
Let ❲x❳ as number Then  ⎩254⎭
    For ❲x❳ = 34 do  ⎩255⎭
        [❲a1❳] := ❲x❳  ⎩256⎭
    End  ⎩257⎭
End  ⎩258⎭
  ⎩259⎭
⎝ ---- Test 61: LET followed by FOR with local variable | expected: {'A1': 34}⎠  ⎩260⎭
Let ❲x❳ as number  ⎩261⎭
[❲a1❳] := ❲x❳  ⎩262⎭
For ❲x❳ = 34  ⎩263⎭
  ⎩264⎭
⎝ ---- Test 62: LET followed by global variable declaration | expected: {'A1': 34}⎠  ⎩265⎭
Let ❲x❳ as number  ⎩266⎭
[❲a1❳] := ❲x❳  ⎩267⎭
: ❲x❳ = 34  ⎩268⎭
  ⎩269⎭
⎝ ---- Test 63: LET with constraint x > 10 | expected: {'A1': 34}⎠  ⎩270⎭
: ❲x❳ = 34  ⎩271⎭
Let ❲x❳ > 10 Then  ⎩272⎭
    [❲a1❳] := ❲x❳  ⎩273⎭
End  ⎩274⎭
  ⎩275⎭
⎝ ---- Test 64: LET with constraint x < 10 | expected: {}⎠  ⎩276⎭
: ❲x❳ = 34  ⎩277⎭
Let ❲x❳ < 10 Then  ⎩278⎭
    [❲a1❳] := ❲x❳  ⎩279⎭
End  ⎩280⎭
  ⎩281⎭
⎝ ---- Test 65: LET with constraint x < 10 halting execution | expected: {}⎠  ⎩282⎭
: ❲x❳ = 34  ⎩283⎭
Let ❲x❳ < 10  ⎩284⎭
[❲a1❳] := ❲x❳  ⎩285⎭
  ⎩286⎭
⎝ ---- Test 66: LET chain with dependencies X -> Y -> Z | expected: {'A1': 8}⎠  ⎩287⎭
Let ❲x❳ = 2 AND ❲y❳ = ❲x❳ * 5 AND ❲z❳ = ❲y❳ - ❲x❳  ⎩288⎭
[❲a1❳] := ❲z❳  ⎩289⎭
  ⎩290⎭
⎝ ---- Test 67: LET chain with wrong order (Y uses X before defined) | expected: error⎠  ⎩291⎭
Let ❲y❳ = ❲x❳ * 5 AND ❲x❳ = 2  ⎩292⎭
[❲a1❳] := ❲y❳  ⎩293⎭
  ⎩294⎭
⎝ ---- Test 68: LET with array and named dimension | expected: {'A1': 'Alice', 'B1': 'Bob', 'C1': 'Carla', 'D1': 'Dylan', 'E1': 'Edith'}⎠  ⎩295⎭
For ❲names❳ dim 0 to 4  ⎩296⎭
Let ❲names❳ = {"Alice", "Bob", "Carla", "Dylan", "Edith"}  ⎩297⎭
[^❲a1❳] := ❲names❳  ⎩298⎭
  ⎩299⎭
⎝ ---- Test 69: Global assignment used in FOR | expected: {'A1': 4.2}⎠  ⎩300⎭
: ❲n❳ = (❲m❳ + 10) / 10  ⎩301⎭
[❲a1❳] := ❲n❳  ⎩302⎭
For ❲m❳ = 32  ⎩303⎭
  ⎩304⎭
⎝ ---- Test 70: LET with array access (index and label) | expected: {'A1': 'Alice', 'B1': 'Carla'}⎠  ⎩305⎭
For ❲names❳ dim 0 to 4  ⎩306⎭
Let ❲names❳ = {"Alice", "Bob", "Carla", "Dylan", "Edith"}  ⎩307⎭
[❲a1❳] := ❲names❳(0)  ⎩308⎭
[❲b1❳] := ❲names❳[3]  ⎩309⎭
  ⎩310⎭
⎝ ---- Test 71: Define custom type and array of objects | expected: {'A1': 1.0, 'B1': 'V'}⎠  ⎩311⎭
Define ❲tensor❳ as Type  ⎩312⎭
    : ❲name❳ as text  ⎩313⎭
End ❲tensor❳  ⎩314⎭
  ⎩315⎭
For ❲v❳ as ❲tensor❳ with (❲name❳ = "V", ❲grid❳ dim {4, 4, 2} = 1.0)   ⎩316⎭
[❲a1❳] := ❲v❳.❲grid❳{4, 4, 1}  ⎩317⎭
[❲b1❳] := ❲v❳.❲name❳  ⎩318⎭
  ⎩319⎭
⎝ ---- Test 72: Define custom type and array with no constraint for {4, 4, 2} | expected: {'A1': 4.0, 'B1': 7.0, 'C1': 'V'}⎠  ⎩320⎭
Define ❲tensor❳ as Type  ⎩321⎭
    : ❲name❳ as text  ⎩322⎭
End ❲tensor❳  ⎩323⎭
  ⎩324⎭
For ❲v❳ as ❲tensor❳ with (❲name❳ = "V", ❲grid❳ dim {4, 4, 2} = {1,1,1,1;2,2,2,2;3,3,3,3;4,4,4,4} | {1,2,3,4;2,3,4,5;3,4,5,6;4,5,6,7})  ⎩325⎭
[❲a1❳] := ❲v❳.❲grid❳{4, 4, 1}  ⎩326⎭
[❲b1❳] := ❲v❳.❲grid❳{4, 4, 2}  ⎩327⎭
[❲c1❳] := ❲v❳.❲name❳  ⎩328⎭
  ⎩329⎭
⎝ ---- Test 73: Define custom type and array with variable assignment for {4, 4, 3} | expected: {'A1': 3.0, 'B1': 7.0, 'C1': 'V', 'D1': 11.0}⎠  ⎩330⎭
Define ❲tensor❳ as Type  ⎩331⎭
    : ❲name❳ as text  ⎩332⎭
End ❲tensor❳  ⎩333⎭
  ⎩334⎭
For ❲var❳ = {1,1,1,1;2,2,2,2;3,3,3,3;4,4,4,4} | {1,2,3,4;2,3,4,5;3,4,5,6;4,5,6,7} | {11,2,3,4;2,3,4,5;3,4,5,6;4,5,6,7}  ⎩335⎭
For ❲v❳ as ❲tensor❳ with (❲name❳ = "V", ❲grid❳ dim {4, 4, 3} = ❲var❳)  ⎩336⎭
[❲a1❳] := ❲v❳.❲grid❳{3, 1, 2}  ⎩337⎭
[❲b1❳] := ❲v❳.❲grid❳{4, 4, 2}  ⎩338⎭
[❲c1❳] := ❲v❳.❲name❳  ⎩339⎭
[❲d1❳] := ❲v❳.❲grid❳{1, 1, 3}  ⎩340⎭
  ⎩341⎭
⎝ ---- Test 74: If condition is false, whole block | expected: {}⎠  ⎩342⎭
Let ❲v❳ = 33  ⎩343⎭
[❲a1❳] := "single digit"  ⎩344⎭
If ❲v❳ < 10  ⎩345⎭
  ⎩346⎭
⎝ ---- Test 75: If condition is true, whole block | expected: {'A1': 'single digit'}⎠  ⎩347⎭
Let ❲v❳ = 1  ⎩348⎭
[❲a1❳] := "single digit"  ⎩349⎭
If ❲v❳ < 10  ⎩350⎭
  ⎩351⎭
⎝ ---- Test 76: If condition is true, whole block with division | expected: {'A1': 5.0}⎠  ⎩352⎭
For ❲a❳ = 20 AND ❲b❳ = 4  ⎩353⎭
[❲a1❳] := ❲a❳ / ❲b❳  ⎩354⎭
If ❲b❳ not = 5  ⎩355⎭
  ⎩356⎭
⎝ ---- Test 77: If then block with else | expected: {'A1': 1}⎠  ⎩357⎭
: ❲name❳ = "Jane"  ⎩358⎭
For ❲friend❳ as number  ⎩359⎭
If ❲name❳ in {"Oscar", "Jane"} Then  ⎩360⎭
	Let ❲friend❳ = 1  ⎩361⎭
Else  ⎩362⎭
	Let ❲friend❳ = 99  ⎩363⎭
End  ⎩364⎭
[❲a1❳] := ❲friend❳  ⎩365⎭
  ⎩366⎭
⎝ ---- Test 78: Single line if then else | expected: {'A1': 99}⎠  ⎩367⎭
: ❲name❳ = "Liz"  ⎩368⎭
For ❲friend❳ as number  ⎩369⎭
If ❲name❳ in {"Oscar", "Jane"} Then Let ❲friend❳ = 1 Else Let ❲friend❳ = 99  ⎩370⎭
[❲a1❳] := ❲friend❳  ⎩371⎭
  ⎩372⎭
⎝ ---- Test 79: Elseif statement | expected: {'A1': 2}⎠  ⎩373⎭
: ❲name❳ = "Jane"  ⎩374⎭
For ❲friend❳ as number  ⎩375⎭
If ❲name❳ = "Oscar" Then  ⎩376⎭
  Let ❲friend❳ = 1  ⎩377⎭
ElseIf ❲name❳ = "Jane" Then  ⎩378⎭
  Let ❲friend❳ = 2  ⎩379⎭
Else  ⎩380⎭
  Let ❲friend❳ = 99  ⎩381⎭
End  ⎩382⎭
[❲a1❳] := ❲friend❳  ⎩383⎭
  ⎩384⎭
⎝ ---- Test 80: Undefined variable, condition is false | expected: {'A1': 'small'}⎠  ⎩385⎭
If ❲v❳ > 10 Then  ⎩386⎭
  [❲a1❳] := "big"  ⎩387⎭
Else  ⎩388⎭
  [❲a1❳] := "small"  ⎩389⎭
End  ⎩390⎭
  ⎩391⎭
⎝ ---- Test 81: Multiple conditions | expected: {'A1': 'true', 'B1': 'true'}⎠  ⎩392⎭
For ❲a❳ = 3 AND ❲b❳ = 7  ⎩393⎭
If ❲b❳ > ❲a❳ AND ❲a❳ <= 3 AND ❲b❳ not = 16 Then  ⎩394⎭
  [❲a1❳] := "true"  ⎩395⎭
End  ⎩396⎭
If ❲b❳ = 5 OR ❲a❳ = 3 Then  ⎩397⎭
  [❲b1❳] := "true"  ⎩398⎭
End  ⎩399⎭
  ⎩400⎭
⎝ ---- Test 82: If constraint on Expression | expected: {'A1': 'true'}⎠  ⎩401⎭
If 1 + 1 = 2 Then  ⎩402⎭
  [❲a1❳] := "true"  ⎩403⎭
End  ⎩404⎭
  ⎩405⎭
⎝ ---- Test 83: If constraint on Expression with variable | expected: {'A1': 'true'}⎠  ⎩406⎭
For ❲a❳ = 3  ⎩407⎭
If ❲a❳ * 3 = 9 Then [❲a1❳] := "true"  ⎩408⎭
  ⎩409⎭
⎝ ---- Test 84: If constraint on Expression with comparison | expected: {'A1': 'true'}⎠  ⎩410⎭
For ❲a❳ = 3  ⎩411⎭
If 10 > ❲a❳ * 3 Then [❲a1❳] := "true"  ⎩412⎭
  ⎩413⎭
⎝ ---- Test 85: For loop with range | expected: {'A1': 'hello', 'A2': 'hello', 'A3': 'hello'}⎠  ⎩414⎭
For ❲i❳ in 1 to 3  ⎩415⎭
[❲a❳{❲i❳}] := "hello"  ⎩416⎭
  ⎩417⎭
⎝ ---- Test 86: Combining loops | expected: {'A1': 8, 'A2': 9}⎠  ⎩418⎭
For ❲a❳ in 1 to 1000  ⎩419⎭
For ❲b❳ in 8 to 9  ⎩420⎭
Push [❲a❳{❲a❳}] = ❲b❳  ⎩421⎭
  ⎩422⎭
⎝ ---- Test 87: Combining loops with different ranges | expected: {'A1': 8, 'A2': 9}⎠  ⎩423⎭
For ❲a❳ in 1 to 2  ⎩424⎭
For ❲b❳ in 8 to 90  ⎩425⎭
Push [❲a❳{❲a❳}] = ❲b❳  ⎩426⎭
  ⎩427⎭
⎝ ---- Test 88: For loop block | expected: {'A1': 4, 'A2': 5, 'A3': 6}⎠  ⎩428⎭
For ❲i❳ in 1 to 3 do  ⎩429⎭
	[❲a❳{❲i❳}] := ❲i❳ + 3  ⎩430⎭
End  ⎩431⎭
  ⎩432⎭
⎝ ---- Test 89: For loop block with set | expected: {'A1': 4, 'A2': 5, 'A3': 6}⎠  ⎩433⎭
For ❲i❳ in {1, 2, 3} do  ⎩434⎭
	[❲a❳{❲i❳}] := ❲i❳ + 3  ⎩435⎭
End  ⎩436⎭
  ⎩437⎭
⎝ ---- Test 90: Nested loop with AND | expected: {'A1': 9, 'A2': 10, 'A3': 18, 'A4': 20}⎠  ⎩438⎭
For ❲a❳ in {1, 2} AND ❲b❳ in {9, 10} do  ⎩439⎭
  [❲a❳{2 * ❲a❳ + ❲b❳ - 10}] := ❲a❳ * ❲b❳  ⎩440⎭
End  ⎩441⎭
  ⎩442⎭
⎝ ---- Test 91: Loop with index | expected: {'A1': 9, 'A2': 10}⎠  ⎩443⎭
For ❲b❳ in {9, 10} index ❲i❳ do  ⎩444⎭
	[❲a❳{❲i❳}] := ❲b❳  ⎩445⎭
End  ⎩446⎭
  ⎩447⎭
⎝ ---- Test 92: Loop with step and index | expected: {'A1': 9, 'A2': 12, 'A3': 15}⎠  ⎩448⎭
For ❲b❳ in 9 to 15 step 3 index ❲i❳ do  ⎩449⎭
	[❲a❳{❲i❳}] := ❲b❳  ⎩450⎭
End  ⎩451⎭
  ⎩452⎭
⎝ ---- Test 93: Nested loop with step and index | expected: {'A4': 9, 'A5': 12, 'A6': 15, 'A7': 18, 'A8': 24, 'A9': 30}⎠  ⎩453⎭
For ❲a❳ in {1, 2} index ❲i❳ AND ❲b❳ in 9 to 15 step 3 index ❲j❳ do  ⎩454⎭
  [❲a❳{3 * ❲i❳ + ❲j❳}] := ❲a❳ * ❲b❳  ⎩455⎭
End  ⎩456⎭
  ⎩457⎭
⎝ ---- Test 94: If condition Dimension constraint - single element | expected: {'A1': 'true'}⎠  ⎩458⎭
For ❲x❳ = {3}  ⎩459⎭
If ❲x❳ dim 1 Then  ⎩460⎭
  [❲a1❳] := "true"  ⎩461⎭
Else  ⎩462⎭
  [❲a1❳] := "false"  ⎩463⎭
End  ⎩464⎭
  ⎩465⎭
⎝ ---- Test 95: If condition Dimension constraint - array | expected: {'A1': 'false'}⎠  ⎩466⎭
For ❲x❳ = {3, 8}  ⎩467⎭
If ❲x❳ dim 1 Then  ⎩468⎭
  [❲a1❳] := "true"  ⎩469⎭
Else  ⎩470⎭
  [❲a1❳] := "false"  ⎩471⎭
End  ⎩472⎭
  ⎩473⎭
⎝ ---- Test 96: If condition Dimension constraint - 2D | expected: {'A1': 'true'}⎠  ⎩474⎭
For ❲x❳ = {3, 8}  ⎩475⎭
If ❲x❳ dim 2 Then  ⎩476⎭
  [❲a1❳] := "true"  ⎩477⎭
Else  ⎩478⎭
  [❲a1❳] := "false"  ⎩479⎭
End  ⎩480⎭
  ⎩481⎭
⎝ ---- Test 97: Dimension condition two-dim | expected: {'A1': 'true'}⎠  ⎩482⎭
For ❲x❳ = {3, 8; 1, 0}  ⎩483⎭
If ❲x❳ dim {2, 2} Then  ⎩484⎭
  [❲a1❳] := "true"  ⎩485⎭
Else  ⎩486⎭
  [❲a1❳] := "false"  ⎩487⎭
End  ⎩488⎭
  ⎩489⎭
⎝ ---- Test 98: Dimension condition zero-dim | expected: {'A1': 'false'}⎠  ⎩490⎭
For ❲x❳ = 3  ⎩491⎭
If ❲x❳ dim 1 Then  ⎩492⎭
  [❲a1❳] := "true"  ⎩493⎭
Else  ⎩494⎭
  [❲a1❳] := "false"  ⎩495⎭
End  ⎩496⎭
  ⎩497⎭
⎝ ---- Test 99: Dimension condition zero-dim with * | expected: {'A1': 'false'}⎠  ⎩498⎭
For ❲x❳ = 3  ⎩499⎭
If ❲x❳ dim * Then  ⎩500⎭
  [❲a1❳] := "true"  ⎩501⎭
Else  ⎩502⎭
  [❲a1❳] := "false"  ⎩503⎭
End  ⎩504⎭
  ⎩505⎭
⎝ ---- Test 100: Dimension condition zero-dim with {} | expected: {'A1': 'true'}⎠  ⎩506⎭
For ❲x❳ = 3  ⎩507⎭
If ❲x❳ dim {} Then  ⎩508⎭
  [❲a1❳] := "true"  ⎩509⎭
Else  ⎩510⎭
  [❲a1❳] := "false"  ⎩511⎭
End  ⎩512⎭
  ⎩513⎭
⎝ ---- Test 101: If condition Type constraint - uninitialized | expected: {'A1': 'true'}⎠  ⎩514⎭
For ❲z❳ as text  ⎩515⎭
If ❲z❳ as text Then  ⎩516⎭
  [❲a1❳] := "true"  ⎩517⎭
Else  ⎩518⎭
  [❲a1❳] := "false"  ⎩519⎭
End  ⎩520⎭
  ⎩521⎭
⎝ ---- Test 102: If condition Type constraint - string value | expected: {'A1': 'true'}⎠  ⎩522⎭
For ❲z❳ = "Grid"  ⎩523⎭
If ❲z❳ as text Then  ⎩524⎭
  [❲a1❳] := "true"  ⎩525⎭
Else  ⎩526⎭
  [❲a1❳] := "false"  ⎩527⎭
End  ⎩528⎭
  ⎩529⎭
⎝ ---- Test 103: If condition Type constraint - number value | expected: {'A1': 'false'}⎠  ⎩530⎭
For ❲z❳ = 99  ⎩531⎭
If ❲z❳ as text Then  ⎩532⎭
  [❲a1❳] := "true"  ⎩533⎭
Else  ⎩534⎭
  [❲a1❳] := "false"  ⎩535⎭
End  ⎩536⎭
  ⎩537⎭
⎝ ---- Test 104: If condition Type and Dimension constraint | expected: {'A1': 'true'}⎠  ⎩538⎭
For ❲z❳ = "Grid"  ⎩539⎭
If ❲z❳ as text dim {} Then  ⎩540⎭
  [❲a1❳] := "true"  ⎩541⎭
Else  ⎩542⎭
  [❲a1❳] := "false"  ⎩543⎭
End  ⎩544⎭
  ⎩545⎭
⎝ ---- Test 105: If condition Type and Dimension constraint - array | expected: {'A1': 'true'}⎠  ⎩546⎭
For ❲z❳ = {"Grid", "lang"}  ⎩547⎭
If ❲z❳ as text dim * Then  ⎩548⎭
  [❲a1❳] := "true"  ⎩549⎭
Else  ⎩550⎭
  [❲a1❳] := "false"  ⎩551⎭
End  ⎩552⎭
  ⎩553⎭
⎝ ---- Test 106: If condition Type and Dimension constraint - scalar | expected: {'A1': 'false'}⎠  ⎩554⎭
For ❲z❳ = "Grid"  ⎩555⎭
If ❲z❳ as text dim * Then  ⎩556⎭
  [❲a1❳] := "true"  ⎩557⎭
Else  ⎩558⎭
  [❲a1❳] := "false"  ⎩559⎭
End  ⎩560⎭
  ⎩561⎭
⎝ ---- Test 107: If condition Possible Values constraint - in set | expected: {'A1': 'true'}⎠  ⎩562⎭
For ❲z❳ = "Grid"  ⎩563⎭
If ❲z❳ in {"Grid", "lang", "2025"} Then  ⎩564⎭
  [❲a1❳] := "true"  ⎩565⎭
Else  ⎩566⎭
  [❲a1❳] := "false"  ⎩567⎭
End  ⎩568⎭
  ⎩569⎭
⎝ ---- Test 108: If condition Possible Values constraint - not in set | expected: {'A1': 'false'}⎠  ⎩570⎭
For ❲z❳ = "hello"  ⎩571⎭
If ❲z❳ in {"Grid", "lang", "2025"} Then  ⎩572⎭
  [❲a1❳] := "true"  ⎩573⎭
Else  ⎩574⎭
  [❲a1❳] := "false"  ⎩575⎭
End  ⎩576⎭
  ⎩577⎭
⎝ ---- Test 109: If condition Possible Values constraint - in range | expected: {'A1': 'true'}⎠  ⎩578⎭
For ❲z❳ = 99  ⎩579⎭
If ❲z❳ in 50 to 100 Then  ⎩580⎭
  [❲a1❳] := "true"  ⎩581⎭
Else  ⎩582⎭
  [❲a1❳] := "false"  ⎩583⎭
End  ⎩584⎭
  ⎩585⎭
⎝ ---- Test 110: If condition Unit constraint - with value | expected: {'A1': 'true'}⎠  ⎩586⎭
For ❲z❳ of ❲dollar❳ = 4  ⎩587⎭
If ❲z❳ of ❲dollar❳ Then  ⎩588⎭
  [❲a1❳] := "true"  ⎩589⎭
Else  ⎩590⎭
  [❲a1❳] := "false"  ⎩591⎭
End  ⎩592⎭
  ⎩593⎭
⎝ ---- Test 111: If condition Unit constraint - without value | expected: {'A1': 'true'}⎠  ⎩594⎭
For ❲z❳ of ❲dollar❳  ⎩595⎭
If ❲z❳ of ❲dollar❳ Then  ⎩596⎭
  [❲a1❳] := "true"  ⎩597⎭
Else  ⎩598⎭
  [❲a1❳] := "false"  ⎩599⎭
End  ⎩600⎭
  ⎩601⎭
⎝ ---- Test 112: If condition Unit constraint - different unit | expected: {'A1': 'false'}⎠  ⎩602⎭
For ❲z❳ of ❲peso❳  ⎩603⎭
If ❲z❳ of ❲dollar❳ Then  ⎩604⎭
  [❲a1❳] := "true"  ⎩605⎭
Else  ⎩606⎭
  [❲a1❳] := "false"  ⎩607⎭
End  ⎩608⎭
  ⎩609⎭
⎝ ---- Test 113: Full Fibonacci Sequence (30 elements) | expected: {'A1': 1, 'B1': 1, 'A2': 1, 'B2': 2, 'A3': 2, 'B3': 3, 'A4': 3, 'B4': 5, 'A5': 5, 'B5': 8, 'A6': 8, 'B6': 13, 'A7': 13, 'B7': 21, 'A8': 21, 'B8': 34, 'A9': 34, 'B9': 55, 'A10': 55, 'B10': 89, 'A11': 89, 'B11': 144, 'A12': 144, 'B12': 233, 'A13': 233, 'B13': 377, 'A14': 377, 'B14': 610, 'A15': 610, 'B15': 987, 'A16': 987, 'B16': 1597, 'A17': 1597, 'B17': 2584, 'A18': 2584, 'B18': 4181, 'A19': 4181, 'B19': 6765, 'A20': 6765, 'B20': 10946, 'A21': 10946, 'B21': 17711, 'A22': 17711, 'B22': 28657, 'A23': 28657, 'B23': 46368, 'A24': 46368, 'B24': 75025, 'A25': 75025, 'B25': 121393, 'A26': 121393, 'B26': 196418, 'A27': 196418, 'B27': 317811, 'A28': 317811, 'B28': 514229, 'A29': 514229, 'B29': 832040, 'A30': 832040, 'B30': 1346269}⎠  ⎩610⎭
For ❲d❳ as number dim {30, 2}  ⎩611⎭
Let ❲d❳[❲a1❳] = 1  ⎩612⎭
Let ❲d❳[❲b1❳] = 1  ⎩613⎭
For ❲i❳ in 1 to 29 do  ⎩614⎭
  Let ❲d❳{❲i❳+1, 1} = ❲d❳{❲i❳, 2}  ⎩615⎭
  Let ❲d❳{❲i❳+1, 2} = ❲d❳{❲i❳, 1} + ❲d❳{❲i❳, 2}  ⎩616⎭
End  ⎩617⎭
[^❲a1❳] := ❲d❳  ⎩618⎭
  ⎩619⎭
⎝ ---- Test 114: Pascal Triangle Sequence | expected: {'A1': 1, 'A2': 4, 'A3': 9, 'A4': 16, 'A5': 25, 'A6': 36, 'A7': 49, 'A8': 64, 'A9': 81, 'A10': 100, 'A11': 121, 'A12': 144, 'A13': 169, 'A14': 196, 'A15': 225}⎠  ⎩620⎭
For ❲d❳ as number dim {15, 1}  ⎩621⎭
Let ❲d❳[❲a1❳] = 1  ⎩622⎭
For ❲i❳ in 3 to 30 step 2 index ❲k❳ do  ⎩623⎭
   Let ❲d❳{❲k❳+1, 1} = ❲d❳{❲k❳, 1} + ❲i❳  ⎩624⎭
End  ⎩625⎭
[^❲a1❳] := ❲d❳  ⎩626⎭
  ⎩627⎭
⎝ ---- Test 115: Fibonacci Sequence with Cell References | expected: {'A1': 1, 'B1': 1, 'A2': 1, 'B2': 2, 'A3': 2, 'B3': 3, 'A4': 3, 'B4': 5, 'A5': 5, 'B5': 8, 'A6': 8, 'B6': 13, 'A7': 13, 'B7': 21, 'A8': 21, 'B8': 34, 'A9': 34, 'B9': 55, 'A10': 55, 'B10': 89, 'A11': 89, 'B11': 144, 'A12': 144, 'B12': 233, 'A13': 233, 'B13': 377, 'A14': 377, 'B14': 610, 'A15': 610, 'B15': 987, 'A16': 987, 'B16': 1597, 'A17': 1597, 'B17': 2584, 'A18': 2584, 'B18': 4181, 'A19': 4181, 'B19': 6765, 'A20': 6765, 'B20': 10946, 'A21': 10946, 'B21': 17711, 'A22': 17711, 'B22': 28657, 'A23': 28657, 'B23': 46368, 'A24': 46368, 'B24': 75025, 'A25': 75025, 'B25': 121393, 'A26': 121393, 'B26': 196418, 'A27': 196418, 'B27': 317811, 'A28': 317811, 'B28': 514229, 'A29': 514229, 'B29': 832040, 'A30': 832040, 'B30': 1346269}⎠  ⎩628⎭
[❲a1❳:❲b1❳] := 1  ⎩629⎭
For ❲i❳ in 1 to 29 do  ⎩630⎭
  [❲a❳{❲i❳+1}] := [❲b❳{❲i❳}]  ⎩631⎭
  [❲b❳{❲i❳+1}] := [❲a❳{❲i❳}] + [❲b❳{❲i❳}]  ⎩632⎭
End  ⎩633⎭
  ⎩634⎭
⎝ ---- Test 116: Array with step and index in FOR loop | expected: {'A1': 1.0, 'B1': 4.0, 'C1': 9.0, 'D1': 16.0, 'E1': 25.0, 'F1': 36.0, 'G1': 49.0, 'H1': 64.0, 'I1': 81.0, 'J1': 100.0, 'K1': 121.0, 'L1': 144.0, 'M1': 169.0, 'N1': 196.0, 'O1': 225.0}⎠  ⎩635⎭
For ❲d❳ as number dim 15  ⎩636⎭
Let ❲d❳[1] = 1  ⎩637⎭
For ❲i❳ in 3 to 30 step 2 index ❲k❳ do  ⎩638⎭
Let ❲d❳(❲k❳+1) = ❲d❳(❲k❳) + ❲i❳  ⎩639⎭
End  ⎩640⎭
[^❲a1❳] := ❲d❳  ⎩641⎭
  ⎩642⎭
⎝ ---- Test 117: Nested FOR loop with dynamic range building grid pattern | expected: {'A1': 0.0, 'B1': 1.0, 'C1': 0.0, 'D1': 0.0, 'E1': 0.0, 'F1': 0.0, 'G1': 0.0, 'H1': 0.0, 'I1': 0.0, 'J1': 0.0, 'K1': 0.0, 'L1': 0.0, 'A2': 0.0, 'B2': 1.0, 'C2': 1.0, 'D2': 0.0, 'E2': 0.0, 'F2': 0.0, 'G2': 0.0, 'H2': 0.0, 'I2': 0.0, 'J2': 0.0, 'K2': 0.0, 'L2': 0.0, 'A3': 0.0, 'B3': 1.0, 'C3': 2.0, 'D3': 1.0, 'E3': 0.0, 'F3': 0.0, 'G3': 0.0, 'H3': 0.0, 'I3': 0.0, 'J3': 0.0, 'K3': 0.0, 'L3': 0.0, 'A4': 0.0, 'B4': 1.0, 'C4': 3.0, 'D4': 3.0, 'E4': 1.0, 'F4': 0.0, 'G4': 0.0, 'H4': 0.0, 'I4': 0.0, 'J4': 0.0, 'K4': 0.0, 'L4': 0.0, 'A5': 0.0, 'B5': 1.0, 'C5': 4.0, 'D5': 6.0, 'E5': 4.0, 'F5': 1.0, 'G5': 0.0, 'H5': 0.0, 'I5': 0.0, 'J5': 0.0, 'K5': 0.0, 'L5': 0.0, 'A6': 0.0, 'B6': 1.0, 'C6': 5.0, 'D6': 10.0, 'E6': 10.0, 'F6': 5.0, 'G6': 1.0, 'H6': 0.0, 'I6': 0.0, 'J6': 0.0, 'K6': 0.0, 'L6': 0.0, 'A7': 0.0, 'B7': 1.0, 'C7': 6.0, 'D7': 15.0, 'E7': 20.0, 'F7': 15.0, 'G7': 6.0, 'H7': 1.0, 'I7': 0.0, 'J7': 0.0, 'K7': 0.0, 'L7': 0.0, 'A8': 0.0, 'B8': 1.0, 'C8': 7.0, 'D8': 21.0, 'E8': 35.0, 'F8': 35.0, 'G8': 21.0, 'H8': 7.0, 'I8': 1.0, 'J8': 0.0, 'K8': 0.0, 'L8': 0.0, 'A9': 0.0, 'B9': 1.0, 'C9': 8.0, 'D9': 28.0, 'E9': 56.0, 'F9': 70.0, 'G9': 56.0, 'H9': 28.0, 'I9': 8.0, 'J9': 1.0, 'K9': 0.0, 'L9': 0.0, 'A10': 0.0, 'B10': 1.0, 'C10': 9.0, 'D10': 36.0, 'E10': 84.0, 'F10': 126.0, 'G10': 126.0, 'H10': 84.0, 'I10': 36.0, 'J10': 9.0, 'K10': 1.0, 'L10': 0.0}⎠  ⎩643⎭
For ❲d❳ as number dim {10, 12}  ⎩644⎭
  ⎩645⎭
Let ❲d❳[❲b1❳] = 1  ⎩646⎭
For ❲a❳ in 2 to 10 AND ❲b❳ in 1 to ❲a❳ do  ⎩647⎭
  Let ❲d❳{❲a❳, ❲b❳+1} = ❲d❳{❲a❳-1, ❲b❳} + ❲d❳{❲a❳-1, ❲b❳+1}  ⎩648⎭
End  ⎩649⎭
  ⎩650⎭
[^❲a1❳] := ❲d❳  ⎩651⎭
  ⎩652⎭
⎝ ---- Test 118: Complex nested FOR loops with IF conditions and set iteration | expected: {'A1': 0.0, 'B1': 1.0, 'C1': 0.0, 'D1': 1.0, 'E1': 1.0, 'F1': 0.0, 'G1': 1.0, 'H1': 2.0, 'I1': 1.0, 'J1': 0.0, 'K1': 1.0, 'L1': 3.0, 'M1': 3.0, 'N1': 1.0, 'O1': 0.0, 'P1': 1.0, 'Q1': 4.0, 'R1': 6.0, 'S1': 4.0, 'T1': 1.0, 'U1': 0.0, 'V1': 1.0, 'W1': 5.0, 'X1': 10.0, 'Y1': 10.0, 'Z1': 5.0, 'AA1': 1.0, 'AB1': 0.0, 'AC1': 1.0, 'AD1': 6.0, 'AE1': 15.0, 'AF1': 20.0, 'AG1': 15.0, 'AH1': 6.0, 'AI1': 1.0, 'AJ1': 0.0, 'AK1': 1.0, 'AL1': 7.0, 'AM1': 21.0, 'AN1': 35.0, 'AO1': 35.0, 'AP1': 21.0, 'AQ1': 7.0, 'AR1': 1.0, 'AS1': 0.0, 'AT1': 1.0, 'AU1': 8.0, 'AV1': 28.0, 'AW1': 56.0, 'AX1': 70.0, 'AY1': 56.0, 'AZ1': 28.0, 'BA1': 8.0, 'BB1': 1.0, 'BC1': 0.0, 'BD1': 1.0, 'BE1': 9.0, 'BF1': 36.0, 'BG1': 84.0, 'BH1': 126.0, 'BI1': 126.0, 'BJ1': 84.0, 'BK1': 36.0, 'BL1': 9.0, 'BM1': 1.0}⎠  ⎩653⎭
For ❲d❳ as number dim 65  ⎩654⎭
Let ❲d❳(2) = 1  ⎩655⎭
For ❲i❳ in 1 to 9 do  ⎩656⎭
  For ❲a❳ = (❲i❳ + 3) * ❲i❳ \ 2 + 1  ⎩657⎭
  For ❲b❳ = (❲i❳ + 1) * ❲i❳ \ 2  ⎩658⎭
  For ❲j❳ in 1 to ❲i❳+1 do  ⎩659⎭
    Let ❲d❳(❲a❳+❲j❳) = ❲d❳(❲b❳+❲j❳-1) + ❲d❳(❲b❳+❲j❳)  ⎩660⎭
  End  ⎩661⎭
End  ⎩662⎭
[^❲a1❳] := ❲d❳  ⎩663⎭
  ⎩664⎭
⎝ ---- Test 119: Binomial coefficient calculation with nested loops | expected: {'A1': 0.0, 'B1': 1.0, 'C1': 0.0, 'D1': 1.0, 'E1': 1.0, 'F1': 0.0, 'G1': 1.0, 'H1': 2.0, 'I1': 1.0, 'J1': 0.0, 'K1': 1.0, 'L1': 3.0, 'M1': 3.0, 'N1': 1.0, 'O1': 0.0}⎠  ⎩665⎭
For ❲d❳ as number dim 15  ⎩666⎭
Let ❲d❳(2) = 1  ⎩667⎭
For ❲i❳ in 1 to 3 do  ⎩668⎭
  Let ❲a❳ = (❲i❳ + 3) * ❲i❳ \ 2 + 1  ⎩669⎭
  Let ❲b❳ = (❲i❳ + 1) * ❲i❳ \ 2  ⎩670⎭
  For ❲j❳ in {1, 2, 3, 4} do  ⎩671⎭
    If ❲j❳ <= ❲i❳+1 Then  ⎩672⎭
      Let ❲d❳(❲a❳+❲j❳) = ❲d❳(❲b❳+❲j❳-1) + ❲d❳(❲b❳+❲j❳)  ⎩673⎭
    End  ⎩674⎭
  End  ⎩675⎭
End  ⎩676⎭
[^❲a1❳] := ❲d❳  ⎩677⎭
  ⎩678⎭
⎝ ---- Test 120: Binomial type with grid spilling (Pascal's Triangle) | expected: {'A1': 0, 'B1': 1, 'B2': 1, 'C2': 1, 'B3': 1, 'C3': 2, 'D3': 1, 'B4': 1, 'C4': 3, 'D4': 3, 'E4': 1, 'B5': 1, 'C5': 4, 'D5': 6, 'E5': 4, 'F5': 1, 'B6': 1, 'C6': 5, 'D6': 10, 'E6': 10, 'F6': 5, 'G6': 1, 'B7': 1, 'C7': 6, 'D7': 15, 'E7': 20, 'F7': 15, 'G7': 6, 'H7': 1, 'B8': 1, 'C8': 7, 'D8': 21, 'E8': 35, 'F8': 35, 'G8': 21, 'H8': 7, 'I8': 1, 'B9': 1, 'C9': 8, 'D9': 28, 'E9': 56, 'F9': 70, 'G9': 56, 'H9': 28, 'I9': 8, 'J9': 1, 'B10': 1, 'C10': 9, 'D10': 36, 'E10': 84, 'F10': 126, 'G10': 126, 'H10': 84, 'I10': 36, 'J10': 9, 'K10': 1}⎠  ⎩679⎭
Define ❲binomial❳ as Type  ⎩680⎭
  [❲b1❳] := 1  ⎩681⎭
  For ❲a❳ in 2 to 10 AND ❲b❳ in 2 to ❲a❳+1 do  ⎩682⎭
    Let ❲grid❳{❲a❳, ❲b❳} = ❲grid❳{❲a❳-1, ❲b❳-1} + ❲grid❳{❲a❳-1, ❲b❳}  ⎩683⎭
  End  ⎩684⎭
End ❲binomial❳  ⎩685⎭
  ⎩686⎭
: ❲bin❳ = new ❲binomial❳()  ⎩687⎭
[^❲a1❳] := ❲bin❳.❲grid❳  ⎩688⎭
  ⎩689⎭
⎝ ---- Test 121: Guard prevents earlier statements | expected: {}⎠  ⎩690⎭
[❲a1❳] := 9  ⎩691⎭
If 2 < 1  ⎩692⎭
[❲a2❳] := 7  ⎩693⎭
  ⎩694⎭
⎝ ---- Test 122: Guard allows execution when true | expected: {'A1': 5, 'A2': 6}⎠  ⎩695⎭
: ❲needle❳ = 5  ⎩696⎭
[❲a1❳] := ❲needle❳  ⎩697⎭
If ❲needle❳ < 10  ⎩698⎭
[❲a2❳] := ❲needle❳ + 1  ⎩699⎭
  ⎩700⎭
⎝ ---- Test 123: Guard blocks when condition false with definition | expected: {}⎠  ⎩701⎭
: ❲limit❳ = 25  ⎩702⎭
[❲a1❳] := 42  ⎩703⎭
If ❲limit❳ < 10  ⎩704⎭
[❲a2❳] := ❲limit❳  ⎩705⎭
  ⎩706⎭
⎝ ---- Test 124: Assignment waits for future FOR variable | expected: {'A1': 11}⎠  ⎩707⎭
[❲a1❳] := ❲total❳ + 1  ⎩708⎭
For ❲total❳ as number = 10  ⎩709⎭
  ⎩710⎭
⎝ ---- Test 125: LET waits for future definition | expected: {'A1': 12}⎠  ⎩711⎭
Let ❲result❳ = ❲base❳ + 5  ⎩712⎭
For ❲base❳ as number = 7  ⎩713⎭
[❲a1❳] := ❲result❳  ⎩714⎭
  ⎩715⎭
⎝ ---- Test 126: IF THEN ELSE simple | expected: {'A1': 'single', 'B1': 'ok'}⎠  ⎩716⎭
: ❲v❳ = 1  ⎩717⎭
[❲a1❳] := "single"  ⎩718⎭
If ❲v❳ < 10 Then [❲b1❳] := "ok"  ⎩719⎭
  ⎩720⎭
⎝ ---- Test 127: FOR range block assignment | expected: {'A1': 1, 'A2': 2, 'A3': 3}⎠  ⎩721⎭
For ❲i❳ in 1 to 3 do  ⎩722⎭
  [❲a❳{❲i❳}] := ❲i❳  ⎩723⎭
End  ⎩724⎭
  ⎩725⎭
⎝ ---- Test 128: Guard prevents runtime errors in body | expected: {}⎠  ⎩726⎭
If 1 = 0  ⎩727⎭
[❲a1❳] := 1 / 0  ⎩728⎭
  ⎩729⎭
⎝ ---- Test 129: Global FOR declaration executes before main | expected: {'A1': 6}⎠  ⎩730⎭
For ❲length❳ as number = 6  ⎩731⎭
[❲a1❳] := ❲length❳  ⎩732⎭
  ⎩733⎭
⎝ ---- Test 130: Doc LET chain dependencies | expected: {'A1': 8.0}⎠  ⎩734⎭
Let ❲x❳ = 2 AND ❲y❳ = ❲x❳ * 5 AND ❲z❳ = ❲y❳ - ❲x❳  ⎩735⎭
[❲a1❳] := ❲z❳  ⎩736⎭
  ⎩737⎭
⎝ ---- Test 131: Doc LET with late declaration | expected: {'A1': 6.0}⎠  ⎩738⎭
Let ❲x❳ = ❲y❳ \ 2  ⎩739⎭
For ❲x❳ as number  ⎩740⎭
For ❲y❳ as number = 13  ⎩741⎭
[❲a1❳] := ❲x❳  ⎩742⎭
  ⎩743⎭
⎝ ---- Test 132: Doc guard sum condition | expected: {'B1': 400, 'B2': 500, 'A1': 9}⎠  ⎩744⎭
[❲b1❳] := 400  ⎩745⎭
[❲b2❳] := 500  ⎩746⎭
[❲a1❳] := 9  ⎩747⎭
If ❲sum❳[❲b1❳:❲b2❳] < 1000  ⎩748⎭
  ⎩749⎭
⎝ ---- Test 133: Doc guard with input allows execution | inputs: ['500'], expected: {'A1': 9}⎠  ⎩750⎭
Input ❲x❳ as number  ⎩751⎭
[❲a1❳] := 9  ⎩752⎭
If ❲x❳ < 1000  ⎩753⎭
  ⎩754⎭
⎝ ---- Test 134: Guard allows execution when true with input | inputs: ['5'], expected: {'A1': 5.0, 'A2': 6.0}⎠  ⎩755⎭
Input ❲needle❳ as number  ⎩756⎭
[❲a1❳] := ❲needle❳  ⎩757⎭
If ❲needle❳ < 10  ⎩758⎭
[❲a2❳] := ❲needle❳ + 1  ⎩759⎭
  ⎩760⎭
⎝ ---- Test 135: Guard blocks when condition false with input | inputs: ['25'], expected: {}⎠  ⎩761⎭
Input ❲limit❳ as number  ⎩762⎭
[❲a1❳] := 42  ⎩763⎭
If ❲limit❳ < 10  ⎩764⎭
[❲a2❳] := ❲limit❳  ⎩765⎭
  ⎩766⎭
⎝ ---- Test 136: Doc global FOR sequence | expected: {'A2': 2, 'A3': 3, 'A4': 4}⎠  ⎩767⎭
For ❲n❳ in 2 to 4 do  ⎩768⎭
  [❲a❳{❲n❳}] := ❲n❳  ⎩769⎭
End  ⎩770⎭
  ⎩771⎭
⎝ ---- Test 137: Tyre size lookup TOYO YARI | inputs: ['TOYO', 'YARI'], expected: {'A1': 195, 'B1': 55, 'C1': 16}⎠  ⎩772⎭
Input ❲make❳ as text  ⎩773⎭
Input ❲model❳ as text  ⎩774⎭
  ⎩775⎭
  ⎩776⎭
  ⎩777⎭
[❲a1❳]: ❲width❳ as number  ⎩778⎭
[❲b1❳]: ❲ratio❳ as number  ⎩779⎭
[❲c1❳]: ❲diameter❳ as number  ⎩780⎭
  ⎩781⎭
If ❲make❳ = "TOYO" Then  ⎩782⎭
  If ❲model❳ = "YARI" Then  ⎩783⎭
    Let ❲width❳ = 195  ⎩784⎭
    Let ❲ratio❳ = 55  ⎩785⎭
    Let ❲diameter❳ = 16  ⎩786⎭
  ElseIf ❲model❳ = "AURI" Then  ⎩787⎭
    Let ❲width❳ = 205  ⎩788⎭
    Let ❲ratio❳ = 55  ⎩789⎭
    Let ❲diameter❳ = 16  ⎩790⎭
  ElseIf ❲model❳ = "CH-R" Then  ⎩791⎭
    Let ❲width❳ = 215  ⎩792⎭
    Let ❲ratio❳ = 60  ⎩793⎭
    Let ❲diameter❳ = 17  ⎩794⎭
  End  ⎩795⎭
End  ⎩796⎭
If ❲make❳ = "MERC" Then  ⎩797⎭
  If ❲model❳ = "A205" Then  ⎩798⎭
    Let ❲width❳ = 205  ⎩799⎭
    Let ❲ratio❳ = 55  ⎩800⎭
    Let ❲diameter❳ = 17  ⎩801⎭
  ElseIf ❲model❳ = "C200" Then  ⎩802⎭
    Let ❲width❳ = 225  ⎩803⎭
    Let ❲ratio❳ = 45  ⎩804⎭
    Let ❲diameter❳ = 18  ⎩805⎭
  End  ⎩806⎭
End  ⎩807⎭
  ⎩808⎭
If ❲len❳(❲make❳) = 4  ⎩809⎭
  ⎩810⎭
⎝ ---- Test 138: Tyre size lookup MERC C200 | inputs: ['MERC', 'C200'], expected: {'A1': 225, 'B1': 45, 'C1': 18}⎠  ⎩811⎭
Input ❲make❳ as text  ⎩812⎭
Input ❲model❳ as text  ⎩813⎭
  ⎩814⎭
  ⎩815⎭
  ⎩816⎭
[❲a1❳]: ❲width❳ as number  ⎩817⎭
[❲b1❳]: ❲ratio❳ as number  ⎩818⎭
[❲c1❳]: ❲diameter❳ as number  ⎩819⎭
  ⎩820⎭
If ❲make❳ = "TOYO" Then  ⎩821⎭
  If ❲model❳ = "YARI" Then  ⎩822⎭
    Let ❲width❳ = 195  ⎩823⎭
    Let ❲ratio❳ = 55  ⎩824⎭
    Let ❲diameter❳ = 16  ⎩825⎭
  ElseIf ❲model❳ = "AURI" Then  ⎩826⎭
    Let ❲width❳ = 205  ⎩827⎭
    Let ❲ratio❳ = 55  ⎩828⎭
    Let ❲diameter❳ = 16  ⎩829⎭
  ElseIf ❲model❳ = "CH-R" Then  ⎩830⎭
    Let ❲width❳ = 215  ⎩831⎭
    Let ❲ratio❳ = 60  ⎩832⎭
    Let ❲diameter❳ = 17  ⎩833⎭
  End  ⎩834⎭
End  ⎩835⎭
If ❲make❳ = "MERC" Then  ⎩836⎭
  If ❲model❳ = "A205" Then  ⎩837⎭
    Let ❲width❳ = 205  ⎩838⎭
    Let ❲ratio❳ = 55  ⎩839⎭
    Let ❲diameter❳ = 17  ⎩840⎭
  ElseIf ❲model❳ = "C200" Then  ⎩841⎭
    Let ❲width❳ = 225  ⎩842⎭
    Let ❲ratio❳ = 45  ⎩843⎭
    Let ❲diameter❳ = 18  ⎩844⎭
  End  ⎩845⎭
End  ⎩846⎭
  ⎩847⎭
If ❲len❳(❲make❳) = 4  ⎩848⎭
  ⎩849⎭
⎝ ---- Test 139: Default input value | expected: {'A1': 5.0}⎠  ⎩850⎭
Input ❲x❳ as number OR = 5  ⎩851⎭
[❲a1❳] := ❲x❳  ⎩852⎭
  ⎩853⎭
⎝ ---- Test 140: INIT allows later updates | expected: {'A1': 7, 'A2': 7}⎠  ⎩854⎭
: ❲x❳ as number init 3  ⎩855⎭
[❲a1❳] := ❲x❳  ⎩856⎭
Push ❲x❳ = 7  ⎩857⎭
[❲a2❳] := ❲x❳  ⎩858⎭
  ⎩859⎭
⎝ ---- Test 141: Function reverse example | expected: {'A1': 'DENIS'}⎠  ⎩860⎭
Define ❲reverse❳ as Function  ⎩861⎭
 Input ❲word❳ as text  ⎩862⎭
 For ❲rev❳ as text init ""  ⎩863⎭
 For ❲i❳ in 1 to ❲len❳(❲word❳) do  ⎩864⎭
  Let ❲c❳ = ❲mid❳(❲word❳, ❲i❳, 1)  ⎩865⎭
  Push ❲rev❳ = ❲c❳ & ❲rev❳  ⎩866⎭
 End  ⎩867⎭
 Return ❲rev❳  ⎩868⎭
End ❲reverse❳  ⎩869⎭
[❲a1❳] := ❲reverse❳("SINED")  ⎩870⎭
  ⎩871⎭
⎝ ---- Test 142: Function square with output | expected: {'A1': 25.0}⎠  ⎩872⎭
Define ❲square❳ as Function  ⎩873⎭
 Input ❲n❳ as number  ⎩874⎭
 Output ❲sq❳ as number  ⎩875⎭
 Push ❲sq❳ = ❲n❳ ^ 2  ⎩876⎭
End ❲square❳  ⎩877⎭
[❲a1❳] := ❲square❳(5)  ⎩878⎭
  ⎩879⎭
⎝ ---- Test 143: Function spellreverse multi-output | expected: {}⎠  ⎩880⎭
Define ❲spellreverse❳ as Function  ⎩881⎭
 Input ❲word❳ as text  ⎩882⎭
 For ❲i❳ in ❲len❳(❲word❳) to 1 step -1 do  ⎩883⎭
  Return ❲mid❳(❲word❳, ❲i❳, 1)  ⎩884⎭
 End  ⎩885⎭
End ❲spellreverse❳  ⎩886⎭
Return ❲spellreverse❳("DIRG")  ⎩887⎭
  ⎩888⎭
⎝ ---- Test 144: Subprocess pushes to caller binding | expected: {'A1': 6}⎠  ⎩889⎭
Define ❲doublepush❳ as Subprocess  ⎩890⎭
 Input ❲n❳ as number  ⎩891⎭
 Output ❲res❳ as number  ⎩892⎭
 Push ❲res❳ = ❲n❳  ⎩893⎭
 Push ❲res❳ = ❲n❳ * 2  ⎩894⎭
End ❲doublepush❳  ⎩895⎭
  ⎩896⎭
❲doublepush❳(3, [^❲a1❳])  ⎩897⎭
  ⎩898⎭
⎝ ---- Test 145: Subprocess grid spill through result | expected: {'C1': 'G', 'D1': 'R', 'E1': 'I', 'F1': 'D'}⎠  ⎩899⎭
Define ❲spellreversesub❳ as Subprocess  ⎩900⎭
 Input ❲word❳ as text  ⎩901⎭
 [^❲a1❳] := {❲mid❳(❲word❳, ❲len❳(❲word❳), 1), ❲mid❳(❲word❳, ❲len❳(❲word❳)-1, 1), ❲mid❳(❲word❳, ❲len❳(❲word❳)-2, 1), ❲mid❳(❲word❳, ❲len❳(❲word❳)-3, 1)}  ⎩902⎭
End ❲spellreversesub❳  ⎩903⎭
  ⎩904⎭
[^❲c1❳] := ❲spellreversesub❳("DIRG").❲grid❳  ⎩905⎭
  ⎩906⎭
⎝ ---- Test 146: Subprocess split name push to binding | expected: {'A1': 'Jane Doe', 'B1': 'Jane', 'C1': 'Doe'}⎠  ⎩907⎭
Define ❲splitname❳ as Subprocess  ⎩908⎭
 Input ❲name❳ as text  ⎩909⎭
 Output ❲result❳ as text  ⎩910⎭
 For ❲parts❳ as text = ❲textsplit❳(❲name❳, " ")  ⎩911⎭
  Push ❲result❳ = ❲parts❳  ⎩912⎭
 End ❲splitname❳  ⎩913⎭
  ⎩914⎭
[❲a1❳] := "Jane Doe"  ⎩915⎭
❲splitname❳([❲a1❳], [^❲b1❳])  ⎩916⎭
  ⎩917⎭
⎝ ---- Test 147: Subprocess grid builder reverse word | expected: {'A1': 'G', 'B1': 'R', 'C1': 'I', 'D1': 'D'}⎠  ⎩918⎭
Define ❲spellreversesub❳ as Subprocess  ⎩919⎭
 Input ❲word❳ as text  ⎩920⎭
 For ❲i❳ in ❲len❳(❲word❳) to 1 step -1 index ❲c❳ do  ⎩921⎭
  Let ❲grid❳{1, ❲c❳} = ❲mid❳(❲word❳, ❲i❳, 1)  ⎩922⎭
 End  ⎩923⎭
End ❲spellreversesub❳  ⎩924⎭
For ❲myword❳ = ❲spellreversesub❳("DIRG")  ⎩925⎭
[^❲a1❳] := ❲myword❳.❲grid❳  ⎩926⎭
  ⎩927⎭
⎝ ---- Test 148: Type constructor with inputs and mutable peer | expected: {'A1': 3.0, 'B1': -2.0, 'A3': 1.2, 'B3': 1001.0}⎠  ⎩928⎭
Define ❲point1❳ as Type  ⎩929⎭
 Input ❲in_x❳ as number  ⎩930⎭
 Input ❲in_y❳ as number  ⎩931⎭
 : ❲x❳ = ❲in_x❳  ⎩932⎭
 : ❲y❳ = ❲in_y❳  ⎩933⎭
End ❲point1❳  ⎩934⎭
Define ❲point2❳ as Type  ⎩935⎭
 : ❲x❳ as number  ⎩936⎭
 : ❲y❳ as number  ⎩937⎭
End ❲point2❳  ⎩938⎭
  ⎩939⎭
: ❲p1❳ = new ❲point1❳(3.0, -2.0)  ⎩940⎭
: ❲p2❳ = new ❲point2❳(1.2, 0.7)  ⎩941⎭
Push ❲p2❳.❲y❳ = 1001.0  ⎩942⎭
[^❲a1❳] := ❲p1❳  ⎩943⎭
[^❲a3❳] := ❲p2❳  ⎩944⎭
  ⎩945⎭
⎝ ---- Test 149: Type constructor immutability conflict | expected: error⎠  ⎩946⎭
Define ❲point1❳ as Type  ⎩947⎭
 Input ❲in_x❳ as number  ⎩948⎭
 Input ❲in_y❳ as number  ⎩949⎭
 : ❲x❳ = ❲in_x❳  ⎩950⎭
 : ❲y❳ = ❲in_y❳  ⎩951⎭
End ❲point1❳  ⎩952⎭
: ❲p1❳ = new ❲point1❳(3.0, -2.0)  ⎩953⎭
Push ❲p1❳.❲y❳ = 1001.0  ⎩954⎭
[❲a1❳] := ❲p1❳.❲y❳  ⎩955⎭
  ⎩956⎭
⎝ ---- Test 150: Member function DistanceToOrigin | expected: {'A1': 5.0}⎠  ⎩957⎭
Define ❲point1❳ as Type  ⎩958⎭
: ❲x❳ as number  ⎩959⎭
: ❲y❳ as number  ⎩960⎭
End ❲point1❳  ⎩961⎭
Define ❲point1❳.❲distancetoorigin❳ as Function  ⎩962⎭
Input ❲p❳ as ❲point1❳  ⎩963⎭
Return ❲sqrt❳(❲p❳.❲x❳ ^ 2 + ❲p❳.❲y❳ ^ 2)  ⎩964⎭
End ❲point1❳.❲distancetoorigin❳  ⎩965⎭
: ❲p1❳ = new ❲point1❳(3, 4)  ⎩966⎭
[❲a1❳] := ❲p1❳.❲distancetoorigin❳  ⎩967⎭
  ⎩968⎭
⎝ ---- Test 151: INIT copies object, equality shares reference | expected: {'A1': -1.0, 'B1': 2.0, 'A3': -1.0, 'B3': 0.0}⎠  ⎩969⎭
Define ❲point❳ as Type  ⎩970⎭
: ❲x❳ as number  ⎩971⎭
: ❲y❳ as number  ⎩972⎭
End ❲point❳  ⎩973⎭
: ❲f❳ = new ❲point❳(-1.0, 0.0)  ⎩974⎭
: ❲p❳ init ❲f❳  ⎩975⎭
Push ❲f❳.❲y❳ = 2.0  ⎩976⎭
[^❲a1❳] := ❲f❳  ⎩977⎭
[^❲a3❳] := ❲p❳  ⎩978⎭
  ⎩979⎭
⎝ ---- Test 152: Equality constraint tracks updates | expected: {'A1': -1.0, 'B1': 2.0}⎠  ⎩980⎭
Define ❲point❳ as Type  ⎩981⎭
: ❲x❳ as number  ⎩982⎭
: ❲y❳ as number  ⎩983⎭
End ❲point❳  ⎩984⎭
: ❲f❳ = new ❲point❳(-1.0, 0.0)  ⎩985⎭
: ❲p❳ = ❲f❳  ⎩986⎭
Push ❲f❳.❲y❳ = 2.0  ⎩987⎭
[^❲a1❳] := ❲p❳  ⎩988⎭
  ⎩989⎭
⎝ ---- Test 153: Input default via equality constraint | expected: {'A1': 25.0}⎠  ⎩990⎭
Define ❲square❳ as Function  ⎩991⎭
 Input ❲x❳ as number OR = 5  ⎩992⎭
 Return ❲x❳ ^ 2  ⎩993⎭
End  ⎩994⎭
: ❲y❳ = ❲square❳()  ⎩995⎭
: ❲z❳ = ❲square❳("circle")  ⎩996⎭
[^❲a1❳] := ❲y❳  ⎩997⎭
  ⎩998⎭
⎝ ---- Test 154: Output INIT vs equality on output | expected: {'A1': 9.0, 'A2': 16.0}⎠  ⎩999⎭
Define ❲square_init❳ as Function  ⎩1000⎭
 Input ❲x❳ as number  ⎩1001⎭
 Output ❲r❳ as number init ❲x❳ ^ 2  ⎩1002⎭
End  ⎩1003⎭
Define ❲square_eq_c❳ as Function  ⎩1004⎭
 Input ❲x❳ as number  ⎩1005⎭
 Output ❲r❳ as number = ❲x❳ ^ 2  ⎩1006⎭
End  ⎩1007⎭
[❲a1❳] := ❲square_init❳(3)  ⎩1008⎭
[❲a2❳] := ❲square_eq_c❳(4)  ⎩1009⎭
  ⎩1010⎭
⎝ ---- Test 155: FOR INIT generator without IN | expected: {'A1': 'GRID', 'A2': 'D', 'A3': 'D'}⎠  ⎩1011⎭
Define ❲spellreverse❳ as Function  ⎩1012⎭
 Input ❲word❳ as text  ⎩1013⎭
 For ❲i❳ in ❲len❳(❲word❳) to 1 step -1 do  ⎩1014⎭
  Return ❲mid❳(❲word❳, ❲i❳, 1)  ⎩1015⎭
 End  ⎩1016⎭
End ❲spellreverse❳  ⎩1017⎭
: ❲acc❳ as text init ""  ⎩1018⎭
For ❲letter❳ as text init ❲spellreverse❳("DIRG") do  ⎩1019⎭
 Push ❲acc❳ = ❲acc❳ & ❲letter❳  ⎩1020⎭
End  ⎩1021⎭
[^❲a1❳] := ❲acc❳  ⎩1022⎭
  ⎩1023⎭
For ❲letter2❳ as text init ❲spellreverse❳("DIRG")  ⎩1024⎭
[❲a2❳] := ❲letter2❳  ⎩1025⎭
  ⎩1026⎭
For ❲letter3❳ as text  ⎩1027⎭
 Push ❲letter3❳ = ❲spellreverse❳("DIRG")  ⎩1028⎭
[❲a3❳] := ❲letter3❳  ⎩1029⎭
  ⎩1030⎭
⎝ ---- Test 156: Subprocess INIT materializes grid result | expected: {'A1': 'G', 'B1': 'R', 'C1': 'I', 'D1': 'D'}⎠  ⎩1031⎭
Define ❲spellreversesub❳ as Subprocess  ⎩1032⎭
 Input ❲word❳ as text  ⎩1033⎭
 For ❲i❳ in ❲len❳(❲word❳) to 1 step -1 index ❲c❳ do  ⎩1034⎭
  Let ❲grid❳{1, ❲c❳} = ❲mid❳(❲word❳, ❲i❳, 1)  ⎩1035⎭
 End  ⎩1036⎭
End ❲spellreversesub❳  ⎩1037⎭
For ❲myword❳ init ❲spellreversesub❳("DIRG")  ⎩1038⎭
[^❲a1❳] := ❲myword❳.❲grid❳  ⎩1039⎭
  ⎩1040⎭
⎝ ---- Test 157: Friendly member function call via For assignment | expected: {'A1': 3.605551275463989}⎠  ⎩1041⎭
Define ❲point1❳ as Type  ⎩1042⎭
 Input ❲in_x❳ as number  ⎩1043⎭
 Input ❲in_y❳ as number  ⎩1044⎭
 : ❲x❳ = ❲in_x❳  ⎩1045⎭
 : ❲y❳ = ❲in_y❳  ⎩1046⎭
End ❲point1❳  ⎩1047⎭
  ⎩1048⎭
For ❲p1❳ = new ❲point1❳(3.0, -2.0)  ⎩1049⎭
  ⎩1050⎭
Define ❲point1❳.❲distancetoorigin❳ as Function  ⎩1051⎭
 Input ❲p❳ as ❲point1❳  ⎩1052⎭
 Return ❲sqrt❳(❲p❳.❲x❳ ^ 2 + ❲p❳.❲y❳ ^ 2)  ⎩1053⎭
End ❲point1❳.❲distancetoorigin❳  ⎩1054⎭
  ⎩1055⎭
For ❲d❳ = ❲p1❳.❲distancetoorigin❳()  ⎩1056⎭
[^❲a1❳] := ❲d❳  ⎩1057⎭
  ⎩1058⎭
⎝ ---- Test 158: Nested generator zipping in Push | expected: {}⎠  ⎩1059⎭
Define ❲spellreverse❳ as Function  ⎩1060⎭
 Input ❲word❳ as text  ⎩1061⎭
 For ❲i❳ in ❲len❳(❲word❳) to 1 step -1 do  ⎩1062⎭
  Return ❲mid❳(❲word❳, ❲i❳, 1)  ⎩1063⎭
 End  ⎩1064⎭
End ❲spellreverse❳  ⎩1065⎭
  ⎩1066⎭
Define ❲combine❳ as Function  ⎩1067⎭
 Input ❲a❳, ❲b❳ as text  ⎩1068⎭
 Return ❲a❳ & "-" & ❲b❳  ⎩1069⎭
End ❲combine❳  ⎩1070⎭
  ⎩1071⎭
Return ❲combine❳(❲spellreverse❳("DIRG"), ❲spellreverse❳("ecin"))  ⎩1072⎭
  ⎩1073⎭
⎝ ---- Test 159: FOR text without dim allows any size | expected: {}⎠  ⎩1074⎭
For ❲a❳ as text = {"hello", "world", "!"}  ⎩1075⎭
  ⎩1076⎭
⎝ ---- Test 160: FOR text with dim size mismatch | expected: error⎠  ⎩1077⎭
For ❲a❳ as text dim 2 = {"hello", "world", "!"}  ⎩1078⎭
  ⎩1079⎭
⎝ ---- Test 161: FOR nested init with push and cell write | expected: {'A1': 'ox'}⎠  ⎩1080⎭
For ❲acc❳ as text init "" do  ⎩1081⎭
  For ❲letter❳ as text init "o" do  ⎩1082⎭
    Push ❲acc❳ = ❲letter❳ & "x"  ⎩1083⎭
    [❲a1❳] := ❲acc❳  ⎩1084⎭
  End  ⎩1085⎭
End  ⎩1086⎭
  ⎩1087⎭
⎝ ---- Test 162: Milestone 4 constraints | expected: {'A1': 3, 'A2': 'Alice', 'B2': 'Bob', 'C2': 'Carla', 'D2': 'Dylan', 'E2': 'Edith'}⎠  ⎩1088⎭
For ❲vmax❳ = 5  ⎩1089⎭
For ❲v❳ <= ❲vmax❳  ⎩1090⎭
Let ❲v❳ = 3  ⎩1091⎭
For ❲names❳ dim 0 to 4  ⎩1092⎭
Let ❲names❳ = {"Alice", "Bob", "Carla", "Dylan", "Edith"}  ⎩1093⎭
[❲a1❳] := ❲v❳  ⎩1094⎭
[^❲a2❳] := ❲names❳  ⎩1095⎭
  ⎩1096⎭
⎝ ---- Test 163: Combined constraints literal values | expected: {'A2': 2, 'A3': 7, 'A4': 'hi', 'B4': 'yo'}⎠  ⎩1097⎭
: ❲choice❳ as number in {1, 2, 3} = 2  ⎩1098⎭
: ❲span❳ as number in 1 to 10 = 7  ⎩1099⎭
: ❲words❳ as text dim 2 = {"hi", "yo"}  ⎩1100⎭
  ⎩1101⎭
[❲a2❳] := ❲choice❳  ⎩1102⎭
[❲a3❳] := ❲span❳  ⎩1103⎭
[^❲a4❳] := ❲words❳  ⎩1104⎭
  ⎩1105⎭
⎝ ---- Test 164: Subprocess writes into dimmed parts | expected: {'A1': 'Jane Doe', 'B1': 'Jane', 'C1': 'Doe'}⎠  ⎩1106⎭
: ❲parts❳ as text dim 2  ⎩1107⎭
  ⎩1108⎭
Define ❲splitname❳ as Subprocess  ⎩1109⎭
 Input ❲name❳ as text  ⎩1110⎭
 Push ❲parts❳ = ❲textsplit❳(❲name❳, " ")  ⎩1111⎭
End ❲splitname❳  ⎩1112⎭
  ⎩1113⎭
[❲a1❳] := "Jane Doe"  ⎩1114⎭
[^❲b1❳] := ❲parts❳  ⎩1115⎭
❲splitname❳([❲a1❳])  ⎩1116⎭
[^❲b1❳] := ❲parts❳  ⎩1117⎭
  ⎩1118⎭
⎝ ---- Test 165: Column interpolation | expected: {'D5': 11, 'CE5': 22}⎠  ⎩1119⎭
: ❲i❳ = 4  ⎩1120⎭
[{❲i❳ :❲a❳}5] := 11  ⎩1121⎭
: ❲j❳ = 4  ⎩1122⎭
[{❲j❳ :❲cb❳}5] := 22  ⎩1123⎭
  ⎩1124⎭
⎝ ---- Test 166: Hidden field skipped on spill | expected: {'A1': 7.0}⎠  ⎩1125⎭
Define ❲secretpoint❳ as Type  ⎩1126⎭
: ❲x❳ as number  ⎩1127⎭
: $❲secret❳ as number init 99  ⎩1128⎭
End ❲secretpoint❳  ⎩1129⎭
: ❲p❳ = new ❲secretpoint❳ with (❲x❳ = 7)  ⎩1130⎭
[^❲a1❳] := ❲p❳  ⎩1131⎭
  ⎩1132⎭
⎝ ---- Test 167: Hidden field access outside type errors | expected: error⎠  ⎩1133⎭
Define ❲secretpoint❳ as Type  ⎩1134⎭
: ❲x❳ as number  ⎩1135⎭
: $❲secret❳ as number init 99  ⎩1136⎭
End ❲secretpoint❳  ⎩1137⎭
: ❲p❳ = new ❲secretpoint❳ with (❲x❳ = 7)  ⎩1138⎭
[❲a1❳] := ❲p❳.❲secret❳  ⎩1139⎭
  ⎩1140⎭
⎝ ---- Test 168: Private helper in constructor | expected: {'A1': 3.0, 'B1': 2.0}⎠  ⎩1141⎭
Define ❲point❳ as Type  ⎩1142⎭
Input ❲in_x❳, ❲in_y❳ as number  ⎩1143⎭
: ❲x❳ as number init ❲in_x❳  ⎩1144⎭
: ❲y❳ as number init ❲in_y❳  ⎩1145⎭
❲shiftright❳(2.0)  ⎩1146⎭
End ❲point❳  ⎩1147⎭
Define ❲point❳.❲shiftright❳ as PrivateHelper  ⎩1148⎭
Input ❲dx❳ as number  ⎩1149⎭
Push ❲x❳ = ❲x❳ + ❲dx❳  ⎩1150⎭
End ❲point❳.❲shiftright❳  ⎩1151⎭
: ❲p❳ = new ❲point❳(1.0, 2.0)  ⎩1152⎭
[^❲a1❳] := ❲p❳  ⎩1153⎭
  ⎩1154⎭
⎝ ---- Test 169: Private helper called from member function | expected: {'A1': 1.5, 'B1': 2.0}⎠  ⎩1155⎭
Define ❲point❳ as Type  ⎩1156⎭
Input ❲in_x❳, ❲in_y❳ as number  ⎩1157⎭
: ❲x❳ as number init ❲in_x❳  ⎩1158⎭
: ❲y❳ as number init ❲in_y❳  ⎩1159⎭
End ❲point❳  ⎩1160⎭
Define ❲point❳.❲shiftright❳ as PrivateHelper  ⎩1161⎭
Input ❲dx❳ as number  ⎩1162⎭
Push ❲x❳ = ❲x❳ + ❲dx❳  ⎩1163⎭
End ❲point❳.❲shiftright❳  ⎩1164⎭
Define ❲point❳.❲goslightlyright❳ as Function  ⎩1165⎭
Input ❲p❳ as ❲point❳  ⎩1166⎭
Output ❲shifted❳ as ❲point❳  ⎩1167⎭
Push ❲shifted❳ = ❲p❳.❲shiftright❳(0.5)  ⎩1168⎭
End ❲point❳.❲goslightlyright❳  ⎩1169⎭
: ❲p❳ = new ❲point❳(1.0, 2.0)  ⎩1170⎭
For ❲s❳ as ❲point❳  ⎩1171⎭
Push ❲s❳ = ❲point❳.❲goslightlyright❳(❲p❳)  ⎩1172⎭
[^❲a1❳] := ❲s❳  ⎩1173⎭
  ⎩1174⎭
⎝ ---- Test 170: Hidden member function call outside type errors | expected: error⎠  ⎩1175⎭
Define ❲point❳ as Type  ⎩1176⎭
: ❲x❳ as number  ⎩1177⎭
: ❲y❳ as number  ⎩1178⎭
End ❲point❳  ⎩1179⎭
Define $❲point❳.❲ontheright❳ as Function  ⎩1180⎭
Input ❲p1❳, ❲p2❳ as ❲point❳  ⎩1181⎭
Return ❲p1❳.❲x❳ > ❲p2❳.❲x❳?  ⎩1182⎭
End $❲point❳.❲ontheright❳  ⎩1183⎭
: ❲p1❳ = new ❲point❳(1.0, 0.0)  ⎩1184⎭
: ❲p2❳ = new ❲point❳(2.0, 0.0)  ⎩1185⎭
[❲a1❳] := ❲p1❳.❲ontheright❳(❲p2❳)  ⎩1186⎭
  ⎩1187⎭
⎝ ---- Test 171: Type instantiation from array without constructor inputs | expected: {'A1': 1.0, 'B1': -5.0}⎠  ⎩1188⎭
Define ❲simple❳ as Type  ⎩1189⎭
: ❲x❳ as number  ⎩1190⎭
: ❲y❳ as number  ⎩1191⎭
End ❲simple❳  ⎩1192⎭
For ❲p❳ as ❲simple❳ = {1.0, -5.0}  ⎩1193⎭
[^❲a1❳] := ❲p❳  ⎩1194⎭
  ⎩1195⎭
⎝ ---- Test 172: New with WITH and shorthand variables | expected: {'A1': 1.0, 'B1': -5.0}⎠  ⎩1196⎭
Define ❲point❳ as Type  ⎩1197⎭
: ❲x❳ as number  ⎩1198⎭
: ❲y❳ as number  ⎩1199⎭
End ❲point❳  ⎩1200⎭
: ❲x❳ = 1.0  ⎩1201⎭
: ❲y❳ = -5.0  ⎩1202⎭
: ❲p❳ = new ❲point❳ with (❲x❳, ❲y❳)  ⎩1203⎭
[^❲a1❳] := ❲p❳  ⎩1204⎭
  ⎩1205⎭
⎝ ---- Test 173: Type extension with Super and new field | expected: {'A1': 2.0, 'B1': 3.0, 'C1': 0.5}⎠  ⎩1206⎭
Define ❲point❳ as Type  ⎩1207⎭
Input ❲in_x❳, ❲in_y❳ as number OR = 0.0  ⎩1208⎭
: ❲x❳ as number init ❲in_x❳  ⎩1209⎭
: ❲y❳ as number init ❲in_y❳  ⎩1210⎭
End ❲point❳  ⎩1211⎭
Define ❲rounddot❳ as Type(❲point❳)  ⎩1212⎭
Input ❲in_x❳, ❲in_y❳ as number OR = 0.0  ⎩1213⎭
Super(❲in_x❳, ❲in_y❳)  ⎩1214⎭
: ❲radius❳ as number OR = 0.1  ⎩1215⎭
End ❲rounddot❳  ⎩1216⎭
: ❲r❳ = new ❲rounddot❳(2.0, 3.0) with (❲radius❳ = 0.5)  ⎩1217⎭
[^❲a1❳] := ❲r❳  ⎩1218⎭
  ⎩1219⎭
⎝ ---- Test 174: Type constraints on numeric subtype | expected: {'A1': 0.25}⎠  ⎩1220⎭
Define ❲ratevalue❳ as Type(number) >= 0.0 <= 1.0  ⎩1221⎭
End ❲ratevalue❳  ⎩1222⎭
For ❲r❳ as ❲ratevalue❳ = 0.25  ⎩1223⎭
[❲a1❳] := ❲r❳  ⎩1224⎭
  ⎩1225⎭
⎝ ---- Test 175: Type constraint violation errors | expected: error⎠  ⎩1226⎭
Define ❲ratevalue❳ as Type(number) >= 0.0 <= 1.0  ⎩1227⎭
End ❲ratevalue❳  ⎩1228⎭
For ❲r❳ as ❲ratevalue❳ = 1.5  ⎩1229⎭
[❲a1❳] := ❲r❳  ⎩1230⎭
  ⎩1231⎭
⎝ ---- Test 176: Member function override polymorphism | expected: {'A1': 0}⎠  ⎩1232⎭
Define ❲point❳ as Type  ⎩1233⎭
: ❲x❳ as number  ⎩1234⎭
: ❲y❳ as number  ⎩1235⎭
End ❲point❳  ⎩1236⎭
Define ❲point❳.❲ontheleft❳ as Function  ⎩1237⎭
Input ❲p1❳, ❲p2❳ as ❲point❳  ⎩1238⎭
Return ❲p1❳.❲x❳ < ❲p2❳.❲x❳?  ⎩1239⎭
End ❲point❳.❲ontheleft❳  ⎩1240⎭
Define ❲rounddot❳ as Type(❲point❳)  ⎩1241⎭
Input ❲in_x❳, ❲in_y❳ as number OR = 0.0  ⎩1242⎭
Super(❲in_x❳, ❲in_y❳)  ⎩1243⎭
: ❲radius❳ as number OR = 0.1  ⎩1244⎭
End ❲rounddot❳  ⎩1245⎭
Define ❲rounddot❳.❲ontheleft❳ as Function  ⎩1246⎭
Input ❲d1❳, ❲d2❳ as ❲rounddot❳  ⎩1247⎭
Return ❲d1❳.❲x❳ + ❲d1❳.❲radius❳ + ❲d2❳.❲radius❳ < ❲d2❳.❲x❳?  ⎩1248⎭
End ❲rounddot❳.❲ontheleft❳  ⎩1249⎭
: ❲r❳ = new ❲rounddot❳(9.0, 0.0) with (❲radius❳ = 0.5)  ⎩1250⎭
: ❲s❳ = new ❲rounddot❳(9.5, 4.0) with (❲radius❳ = 0.5)  ⎩1251⎭
[❲a1❳] := ❲r❳.❲ontheleft❳(❲s❳)  ⎩1252⎭
  ⎩1253⎭
⎝ ---- Test 177: Member function override uses RoundDot | expected: {'A1': 1}⎠  ⎩1254⎭
Define ❲point❳ as Type  ⎩1255⎭
Input ❲in_x❳, ❲in_y❳ as number OR = 0.0  ⎩1256⎭
: ❲x❳ as number init ❲in_x❳  ⎩1257⎭
: ❲y❳ as number init ❲in_y❳  ⎩1258⎭
End ❲point❳  ⎩1259⎭
Define ❲point❳.❲ontheleft❳ as Function  ⎩1260⎭
Input ❲p1❳, ❲p2❳ as ❲point❳  ⎩1261⎭
Return ❲p1❳.❲x❳ < ❲p2❳.❲x❳?  ⎩1262⎭
End ❲point❳.❲ontheleft❳  ⎩1263⎭
Define ❲rounddot❳ as Type(❲point❳)  ⎩1264⎭
Input ❲in_x❳, ❲in_y❳ as number OR = 0.0  ⎩1265⎭
Super(❲in_x❳, ❲in_y❳)  ⎩1266⎭
: ❲radius❳ as number OR = 0.1  ⎩1267⎭
End ❲rounddot❳  ⎩1268⎭
Define ❲rounddot❳.❲ontheleft❳ as Function  ⎩1269⎭
Input ❲d1❳, ❲d2❳ as ❲rounddot❳  ⎩1270⎭
Return ❲d1❳.❲x❳ + ❲d1❳.❲radius❳ + ❲d2❳.❲radius❳ < ❲d2❳.❲x❳?  ⎩1271⎭
End ❲rounddot❳.❲ontheleft❳  ⎩1272⎭
: ❲r❳ = new ❲rounddot❳(9.0, 0.0) with (❲radius❳ = 0.5)  ⎩1273⎭
: ❲p❳ = new ❲rounddot❳(900.0, 0.0) with (❲radius❳ = 0.5)  ⎩1274⎭
[❲a1❳] := ❲r❳.❲ontheleft❳(❲p❳)  ⎩1275⎭
  ⎩1276⎭
⎝ ---- Test 178: Array init fixed dim via LET | expected: {'A1': 12, 'B1': 5, 'C1': 0.3}⎠  ⎩1277⎭
For ❲a❳ as number dim 3  ⎩1278⎭
Let ❲a❳(1) = 12  ⎩1279⎭
Let ❲a❳(2) = 5  ⎩1280⎭
Let ❲a❳(3) = 0.3  ⎩1281⎭
[^❲a1❳] := ❲a❳  ⎩1282⎭
  ⎩1283⎭
⎝ ---- Test 179: Array dim * requires PUSH | expected: error⎠  ⎩1284⎭
For ❲b❳ as number dim *  ⎩1285⎭
Let ❲b❳(1) = 12  ⎩1286⎭
  ⎩1287⎭
⎝ ---- Test 180: Array dim * grows with PUSH | expected: {'A1': 12, 'B1': 5, 'C1': 0.3}⎠  ⎩1288⎭
For ❲c❳ as number dim *  ⎩1289⎭
Push ❲c❳(1) = 12  ⎩1290⎭
Push ❲c❳(2) = 5  ⎩1291⎭
Push ❲c❳(3) = 0.3  ⎩1292⎭
[^❲a1❳] := ❲c❳  ⎩1293⎭
  ⎩1294⎭
⎝ ---- Test 181: Push without dim errors | expected: error⎠  ⎩1295⎭
For ❲d❳ as number  ⎩1296⎭
Push ❲d❳(1) = 12  ⎩1297⎭
  ⎩1298⎭
⎝ ---- Test 182: test if longest match matters⎠  ⎩1299⎭
For ❲forabc❳ as number  ⎩1300⎭
Push ❲forabc❳(1) = 12  ⎩1301⎭
  ⎩1302⎭

